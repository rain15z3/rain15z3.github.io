{"meta":{"title":"洛灵酱的小窝","subtitle":"想要变可爱","description":"以梦为马，不负韶华。","author":"RainbowBird","url":"https://blog.luoling8192.top","root":"/"},"pages":[{"title":"关于","date":"2020-08-21T11:05:34.000Z","updated":"2020-09-03T10:32:00.604Z","comments":true,"path":"about/index.html","permalink":"https://blog.luoling8192.top/about/","excerpt":"","text":".tag { display: inline-block; color: #333; box-sizing: border-box; border-radius: 2px; padding: 10px; margin: 6px 2px; background: #f3f3f3; text-decoration: none; transition: all .25s; -webkit-transition: all .25s; cursor: default; } .tag:hover { background: rgba(0, 0, 0, 0.1); box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; -webkit-box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; } 关于我MtF / INFP / OIer一只为了成为自己喜欢的样子而努力奋斗的小木桶饭。目前在阿卡林省读高一，是一个很菜的OIer（枯。 2020年8月22日之前的博客在博客园可以找到。 这里有我AC的习题代码。 竞赛学习进度 算法学习笔记 标签 INFP 想变得可爱 木桶饭 程序媛 技术栈会点前端 HTML/CSS Javascript Vue 会点后端 NodeJS PHP Python 联系方式快来找我一起玩吖www 各大OJ 洛谷：RainbowBird 牛客：洛灵酱爱次糖 UOJ：luoling8192 LOJ：luoling8192 CodeForces：RainbowBird 社交账号 QQ：1284114089 邮箱：rbxin2003@outlook.com 知乎：秋山雪奈 哔哩哔哩：洛灵酱爱次糖 新浪微博：洛灵酱爱次糖 Github：RainbowBird Gitee：秋山雪奈酱"},{"title":"分类","date":"2020-08-27T03:28:03.591Z","updated":"2020-08-27T03:28:03.596Z","comments":false,"path":"categories/index.html","permalink":"https://blog.luoling8192.top/categories/","excerpt":"","text":""},{"title":"好朋友们","date":"2020-08-27T03:43:11.000Z","updated":"2020-08-29T08:14:56.597Z","comments":true,"path":"friends/index.html","permalink":"https://blog.luoling8192.top/friends/","excerpt":"","text":"欢迎在评论区留言互换友链(〃’▽’〃) 大佬 TURX Kal0rona"},{"title":"","date":"2020-08-27T02:56:45.136Z","updated":"2020-08-27T02:56:45.137Z","comments":true,"path":"js/fireworks.js","permalink":"https://blog.luoling8192.top/js/fireworks.js","excerpt":"","text":"\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t"},{"title":"","date":"2020-08-27T03:06:59.429Z","updated":"2020-08-27T03:06:59.434Z","comments":true,"path":"js/funnytitle.js","permalink":"https://blog.luoling8192.top/js/funnytitle.js","excerpt":"","text":"// 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω"},{"title":"说说","date":"2020-08-27T03:13:55.000Z","updated":"2020-08-27T03:29:23.013Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://blog.luoling8192.top/shuoshuo/","excerpt":"","text":""},{"title":"标签","date":"2020-08-27T03:28:09.071Z","updated":"2020-08-27T03:28:09.078Z","comments":false,"path":"tags/index.html","permalink":"https://blog.luoling8192.top/tags/","excerpt":"","text":""},{"title":"目前进度","date":"2020-08-28T05:21:41.000Z","updated":"2020-08-28T07:45:01.219Z","comments":true,"path":"progress/index.html","permalink":"https://blog.luoling8192.top/progress/","excerpt":"","text":"一级标准 程序的基本结构 标识符和关键字 程序的基本结构 标识符和关键字 基本数据类型 常量和变量 算术表达式和关系表达式 整除，求余运算，常用数学函数 赋值语句，输入输出语句，复合语句，条件语句（不嵌套），循环语句（不嵌套） 二级标准 逻辑表达式 条件嵌套，循环嵌套，数组 枚举，简单排序，简单查找算法 素数与合数，最大公约数，最小公倍数，互质数 三级标准 数制及其转化，信息编码，位运算 字符串类型 子程序 递归 逻辑运算，整数的质因数分解，随机函数 筛选法，欧几里得算法 四级标准 结构类型，文件操作 数据类型的内在含义 贪心法，递推，回溯法，模拟算法 简单的字符串处理 集合及集合的运算，加法原理和乘法原理，简单的排列和组合 五级标准 指针类型 一般线性表，队列，堆栈，二叉树的存储和遍历 排列和组合，高精度数值的处理 二分算法，快速排序，深度优先搜索，宽度优先搜索，简单动态规划 圆排列，可重集排列，鸽笼原理，素因数分解，幂函数，指数函数，对数函数，三角函数，模运算，不等式基础知识 六级标准 树、图的存储 哈希表、集合数据结构 图的最短路，生成树算法，有向图的拓扑排序算法 动态规划的常见模型，分治策略，各种排序算法 可重集组合，二项式定理，数列与级数，归纳与递推，容斥原理，函数的连续性、函数的单调性和极值 七级标准 并查集，线段树，哈弗曼树，二叉排序树，二叉堆 图的连通性算法，最短路，最小生成树的优化算法，二分图的构造、判定及匹配，搜索算法的优化，扩展欧几里得算法 中国剩余定理，剩余类，概率基础知识，解析几何基础知识 八级标准 树状数组，字典树，优先队列，平衡树 网络流算法，复杂的分治思想，树形动态规划，状态压缩动态规划，二分图的匹配，启发式搜索 矩阵概念及其基本运算，线性方程组的解法，迭代法，费马小定理和欧拉定理，母函数 九级标准 块状链表，后缀数组，后缀树，复杂的线段树 动态规划优化，模拟退火算法 计算几何基础知识（点积、叉积、凸包、半平面等知识及应用），数学期望 十级标准 最小树形图，自动机，动态树，树套树，一般图的匹配 双重动态规划，基于连通性的动态规划，线性规划，极大极小搜索算法 三维计算几何，组合游戏中的NIM问题和SG函数，群的概念，置换群，Burnside引理，Polya原理，莫比乌斯反演定理，FFT"},{"title":"相册","date":"2020-08-29T09:25:22.000Z","updated":"2020-08-29T10:09:02.286Z","comments":true,"path":"photos/index.html","permalink":"https://blog.luoling8192.top/photos/","excerpt":"","text":"2020-08-03"},{"title":"","date":"2020-09-05T13:27:16.793Z","updated":"2020-09-05T13:27:16.795Z","comments":true,"path":"css/user.css","permalink":"https://blog.luoling8192.top/css/user.css","excerpt":"","text":"* { /* bug 容错 */ } html { font-family: \"Segoe UI\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, sans-serif !important; text-shadow: rgba(0, 0, 0, .8) 0px 0px 0px; } .darkmode-layer, .darkmode-toggle { bottom: 90px !important; } .github-corner svg { position: fixed !important; } a[href] { transition: all .28s ease-out; position: relative; box-sizing: content-box; } a[href]:hover:not([class*=\"tag\"]) { color: #ff6c6c !important; } .article-title a[href]:hover { color: #555 !important; } .article-title a[href]::after { content: ''; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; position: absolute; background: #555; bottom: 0; left: 0; height: 2px; width: 100%; visibility: hidden; transform: scaleX(0); } .article-title a[href]:hover::after { visibility: visible; transform: scaleX(1); } /* .md a[href] { color: #2196f3 !important; } .md a[href]::after { content: ''; transition: all .1s ease-out; position: absolute; background: #555; bottom: 0; left: 0; height: 1px; width: 100%; } .md .title a::after, .md .new-meta-box .author::after, .md .new-meta-box .category-link::after, .md .new-meta-box .comments-count a::after, .md .prev::after, .md .next::after, .md .item::after, .md .tag::after { width: 0 !important; } */ .post-tags * { font-size: 0.875rem; } .post-tags a { color: #888; transition: all .1s ease-out; } .post-tags a:hover { color: #ff6c6c !important; } article .footer .related_posts .body .vlts-rps { overflow: unset !important; overflow-x: auto !important; } b, strong { /*font-weight: 900 !important;*/ /*background: rgba(128, 128, 128, .35);*/ background: rgba(255, 255, 0, .35); } .shadow { transition: all 0.28s ease; /*background: rgba(255, 255, 255, .8);*/ } .shadow:hover:not([class*=\"l_header\"]) { box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } .friends .content a { display: block; transition: all .28s ease; padding: 0 16px; padding-left: 12px; } .friends .content a:hover { background: var(--color-site-bg); }"}],"posts":[{"title":"【算法学习】01背包","slug":"算法学习-01背包","date":"2020-09-04T15:29:02.000Z","updated":"2020-09-04T15:31:57.995Z","comments":true,"path":"/posts/algorithm-note/01-backpack.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-note/01-backpack.html","excerpt":"今天好像终于搞懂了01背包问题。 先放上代码，过程以后再补。","text":"今天好像终于搞懂了01背包问题。 先放上代码，过程以后再补。 朴素1234567891011121314151617181920212223int T, m;int w[105], v[105];int f[105][105];int main() &#123; cin &gt;&gt; T &gt;&gt; m; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= m; i++) cin &gt;&gt; w[i] &gt;&gt; v[i]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = T; j &gt;= 0; j--) &#123; if (j &gt;= w[i]) &#123; f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; else &#123; f[i][j] = f[i - 1][j]; &#125; &#125; &#125; cout &lt;&lt; f[m][T] &lt;&lt; endl; return 0;&#125; 优化123456789101112131415161718192021int T, m;int w[105], v[105];int f[105];int main() &#123; cin &gt;&gt; T &gt;&gt; m; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= m; i++) cin &gt;&gt; w[i] &gt;&gt; v[i]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = T; j &gt;= 0; j--) &#123; if (j &gt;= w[i]) &#123; f[j] = max(f[j], f[j - w[i]] + v[i]); &#125; &#125; &#125; cout &lt;&lt; f[T] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛-笔记","slug":"algorithm-note","permalink":"https://blog.luoling8192.top/categories/algorithm-note/"}],"tags":[{"name":"动态规划","slug":"DP","permalink":"https://blog.luoling8192.top/tags/DP/"},{"name":"背包","slug":"backpack","permalink":"https://blog.luoling8192.top/tags/backpack/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】线段树","slug":"模板-线段树","date":"2020-09-02T09:23:10.000Z","updated":"2020-09-02T10:58:38.767Z","comments":true,"path":"/posts/algorithm-template/segment-tree.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/segment-tree.html","excerpt":"什么是线段树以下内容摘自 OI-Wiki 线段树是算法竞赛中常用的用来维护区间信息的数据结构。","text":"什么是线段树以下内容摘自 OI-Wiki 线段树是算法竞赛中常用的用来维护区间信息的数据结构。 线段树可以在 $O (\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 线段树维护的信息，需要满足可加性，即能以可以接受的速度合并信息和修改信息，包括在使用懒惰标记时，标记也要满足可加性（例如取模就不满足可加性，对 $4$ 取模然后对 $3$ 取模，两个操作就不能合并在一起做）。 题目链接【模板】线段树 1 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll a[100005];ll tree[100005]; // 左子树下标p*2，右子树下标p*2+1ll lazy[100005]; // 懒惰标签namespace st {// p: 当前数组的下标// l, r: 区间l-r，在数组a里面void build(int p, int l, int r) { lazy[p] = 0; // 懒惰标签清空 if (l == r) { // 如果已经到了最小的部分 tree[p] = a[l]; // 把当前数组a的值赋值给线段树tree[p] return; } int mid = (l + r) / 2; build(p * 2, l, mid); // 建立左子树 build(p * 2 + 1, mid + 1, r); // 建立右子树 tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 当前数的值等于子树的和}// len: 下传的子树区间大小void pushdown(int p, int len) { // 子树节点的懒惰标记加上父亲节点的懒惰标记 lazy[p * 2] += lazy[p]; lazy[p * 2 + 1] += lazy[p]; // 子树更新区间和 tree[p * 2] += (len - len / 2) * lazy[p]; tree[p * 2 + 1] += (len / 2) * lazy[p]; // 清除父亲节点的懒惰标记 lazy[p] = 0;}// x, y: 修改[x,y]这个区间// num: 修改的值，加上一个数void change(int p, int l, int r, int x, int y, int num) { if (x &lt;= l &amp;&amp; y &gt;= r) { // [l,r]区间包含了当前区间[x,y] lazy[p] += num; // 修改区间[l,r]的懒惰标签 tree[p] += (num * ll(r - l + 1)); // 当前区间的区间和加上左右子树的和 return; } // 向下搜索 pushdown(p, (r - l + 1)); // 懒惰标记下传（只下穿一层） int mid = (l + r) / 2; if (x &lt;= mid) change(p * 2, l, mid, x, y, num); // 遍历左子树 if (y &gt; mid) change(p * 2 + 1, mid + 1, r, x, y, num); // 遍历右子树 tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 更新区间和（左子树和右子树的和）}// x, y: 需要查询的区间左右界ll find(int p, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; y &gt;= r) // 如果区间[l,r]被完整包含在了需要查询的区间[x,y]里面 return tree[p]; // 返回区间[l,r]的区间和 int mid = (l + r) / 2; if (lazy[p] != 0) // 如果节点含有懒惰标记 pushdown(p, r - l + 1); // 懒惰标记下传 ll re = 0; if (x &lt;= mid) // 如果需要查询的区间在mid的左边 re += find(p * 2, l, mid, x, y); // 搜索左子树 if (y &gt; mid) // 如果需要查询的区间在mid的右边 re += find(p * 2 + 1, mid + 1, r, x, y); // 搜索右子树 return re;}} // namespace stint main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(\"%lld\", &amp;a[i]); } st::build(1, 1, n); // 建立线段树 for (int i = 1; i &lt;= m; i++) { int op, x, y, k; scanf(\"%d\", &amp;op); if (op == 1) { scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;k); st::change(1, 1, n, x, y, k); } else if (op == 2) { scanf(\"%d %d\", &amp;x, &amp;y); ll ans = st::find(1, 1, n, x, y); printf(\"%lld\\n\", ans); } } return 0;}","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"线段树","slug":"segment-tree","permalink":"https://blog.luoling8192.top/tags/segment-tree/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】字典树","slug":"模板-字典树","date":"2020-08-31T09:49:05.000Z","updated":"2020-08-31T13:39:29.501Z","comments":true,"path":"/posts/algorithm-template/trie-tree.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/trie-tree.html","excerpt":"什么是字典树 原理在这篇文章中讲的很清楚了，非常感谢。","text":"什么是字典树 原理在这篇文章中讲的很清楚了，非常感谢。 为什么要用字典树Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 代码实现1234567891011121314151617181920212223242526int trie[10005][26]; // 最大深度 最大字符集int book[10005]; // 用于标识是否为终结点int cur = 1; // 从1开始因为0是根节点void insert(string str) &#123; int p = 0; // 从根节点开始遍历 for (int i = 0; i &lt; str.length(); i++) &#123; int c = str[i] - &#x27;a&#x27;; // 把小写字母转换为数字（从0-25，分别对应a-z） if (!trie[p][c]) // 如果当前节点没有一条为c的边 trie[p][c] = cur++; // 添加一条边，边总数加1 p = trie[p][c]; // 指针移到当前节点 &#125; book[p] = 1; // 遍历完成，在最后一条边上打上结束标记&#125;int search(string str) &#123; int p = 0; for (int i = 0; i &lt; str.length(); i++) &#123; int c = str[i] - &#x27;a&#x27;; if (!trie[p][c]) return false; // 如果当前字母的边没有找到则返回false p = trie[p][c]; // 指针指向当前节点 &#125; return book[p] == 1; // 如果当前边有结束标记则说明找到了&#125; 简单写完main函数就完成了一个字典树的demo。 123456789101112131415161718int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; string a; cin &gt;&gt; a; insert(a); &#125; for (int i = 0; i &lt; m; i++) &#123; string a; cin &gt;&gt; a; if (search(a)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 运行效果","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"字典树","slug":"trie-tree","permalink":"https://blog.luoling8192.top/tags/trie-tree/"}]},{"title":"【题解】NOIP2005 校门外的树（离散化实现）","slug":"题解-NOIP2005-校门外的树-离散化实现","date":"2020-08-30T14:03:45.000Z","updated":"2020-08-31T10:13:48.613Z","comments":true,"path":"/posts/algorithm-solution/noip2005-school-tree.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2005-school-tree.html","excerpt":"题目链接P1047 校门外的树 今天用这道题目来练习一下离散化。 当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。","text":"题目链接P1047 校门外的树 今天用这道题目来练习一下离散化。 当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。 题目代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node &#123; int pos; // 位置 int num; // 前缀和&#125; a[100005];int cmp(Node a, Node b) &#123; return a.pos &lt; b.pos;&#125;int l, m;int main() &#123; cin &gt;&gt; l &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; // 离散化存储 a[i*2-1].pos = x; // 左端点的位置 a[i*2-1].num = 1; // 左端点用1表示 a[i*2].pos = y + 1; // 右端点的位置（差分用，所以这里是y+1） a[i*2].num = -1; // 右端点用-1表示 &#125; sort(a + 1, a + m * 2 + 1, cmp); // 按照左端点的位置升序排列 // 前缀和 int sum = 0, total = 0; for (int i = 1; i &lt;= m * 2; i++) &#123; // 一共有2m个点，全部遍历一遍 sum += a[i].num; // sum用来存储当前状态 // 当sum的值由0变为1时说明中间经过了一段没有树的区间 if (sum == 1 &amp;&amp; a[i].num == 1) &#123; // 这时a[i]是左端点，a[i-1]是上个区间的右端点 total += a[i].pos - a[i-1].pos; // 加上区间长度 &#125; &#125; // 最后一个右端点到区间终点的距离 total += l - a[m*2].pos + 1; cout &lt;&lt; total &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"离散化","slug":"discretized","permalink":"https://blog.luoling8192.top/tags/discretized/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://blog.luoling8192.top/tags/prefix-sum/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】快速幂","slug":"模板-快速幂","date":"2020-08-30T11:27:01.000Z","updated":"2020-08-31T10:17:06.616Z","comments":true,"path":"/posts/algorithm-template/template-quick-pow.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/template-quick-pow.html","excerpt":"今天学了倍增，终于把非递归快速幂看懂了。","text":"今天学了倍增，终于把非递归快速幂看懂了。 还是把$a^n$拆分成二进制形式。 例如：$$a^{10} = a^{(1010) _ 2} = a^{1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0} = a^{1 * 2^3} * a^{1 * 2^1}$$ 我们可以通过倍增的方法先计算$\\mod p$意义下的$a^1$，$a^2$，$a^4$，$a^8$，$a^{16}$，$a^{32}$，再把它们根据$b$的二进制拆分乘起来。 下面请看代码实现： 123456789101112// a ^ b % pint quick_pow(int a, int b, int p) &#123; int t = a; // 倍增（a^1 a^2 a^3 ...） int ans = 1; while (b &gt; 0) &#123; if (b &amp; 1) // 二进制最后一位是1 ans = (ans * t) % p; t = (t * t) % p; b &gt;&gt;= 1; // 计算下一个二进制的值 &#125; return ans;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"倍增","slug":"redouble","permalink":"https://blog.luoling8192.top/tags/redouble/"},{"name":"快速幂","slug":"quick-pow","permalink":"https://blog.luoling8192.top/tags/quick-pow/"}],"author":[{"name":"RainbowBird"}]},{"title":"算法学习笔记","slug":"算法学习笔记","date":"2020-08-29T11:20:25.000Z","updated":"2020-09-03T10:43:46.184Z","comments":true,"path":"/posts/algorithm-note/algorithmic-learning-notes.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-note/algorithmic-learning-notes.html","excerpt":"蒟蒻的学习笔记，时不时拿出来看一看。","text":"蒟蒻的学习笔记，时不时拿出来看一看。 数论最大公约数gcd(a, b) = gcd(b, a % b) 123456789int gcd(int a, int b) &#123; int mod; while(b &gt; 0) &#123; mod = a % b; a = b; b = mod; &#125; return a;&#125; 最小公倍数123int lcm(int a, b) &#123; return a * b / gcd(a, b);&#125; 互质数互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。 基本不等式$$a+b \\geq 2 \\sqrt{ab}$$ 算数基本定理任何一个大于1的正整数都能唯一分解成有限个质数的乘积，可以写作：$$N = p_1^{c_1}p_2^{c_2}p_3^{c_3} \\cdots p_m^{c_m}$$其中$p_1,p_2,p_3 \\cdots p_i$都是质数且递增，$c_i$都是正整数。 基本算数定理的推论 $N$的正整数合集为$p_1^{b_1}p_2^{b_2}p_3^{b_3} \\cdots p_m^{b_m}$，其中$0 \\leq b_i \\leq c_i$。 $N$的正约数个数为$\\prod^m_{i=1}(c_i+1)$。 $N$的所有正约数的和为$(1+p_1+{p_1}^2+ \\cdots +{p_1}^{c_1}) \\times \\cdots \\times ((1+p_m+{p_m}^2+ \\cdots +{p_m}^{c_1}) = \\prod^m_{m=1}(\\sum^{c_i}_{j=0}(p_m)^j)$。 欧拉函数两个数的gcd等于$1$，即两个数互质。 $1$到$n$中与$n$互质的数的个数成为欧拉函数记$\\phi(n)$。 $$\\phi(n) = N \\times \\frac{p^1-1}{p^1} \\times \\frac{p^2-1}{p^2} \\times \\cdots \\times \\frac{p^m-1}{p^m}$$ 同余若整数$a$和整数$b$除以正整数$m$的余数相等，则称为$a$，$b$模$m$余数相同，则称为$a$，$b$模$m$同余，记为$a \\equiv b\\pmod m$。 同余满足反身性、对称性、传递性。 $a \\equiv a\\pmod m$ 若$a \\equiv b\\pmod m$，则$b \\equiv a\\pmod m$ 若$a \\equiv b\\pmod m$，$b \\equiv c\\pmod m$，则$a \\equiv c\\pmod m$ 斐波那契数列$f(1) = 1$ $f(2) = 1$ $f(3) = f(1) + f(2) = f(3-2) + f(3-1)$ $f(n) = f(n-2) + f(n-1)$ 卡特兰数$f(0) = 1$ $f(1) = 1$ $f(n) = f(0) \\times f(n-1) + f(1) \\times f(n-2) \\cdots + f(n) \\times f(0)$ 应用：长度为n的栈一共有多少种出栈的方法。 二叉树前序遍历：根左右 中序遍历：左根右 后序遍历：左右根 初赛知识点渐进时间复杂度 位运算异或相同为0，不同为1。 $n^{\\wedge}0$不变，$n^{\\wedge}1$取反。 补码源码的绝对值取反加1。 运算顺序赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算数运算符 排列组合 全排列$$A^m_n=n \\times (n-1) \\times (n-2) \\times \\cdots \\times (n-m+1) = \\frac{n!}{(n-m)!}$$ 全组合$$C^m_n= \\frac{A^m_n}{A^m_m} = \\frac{n \\times (n-1) \\times (n-2) \\times \\cdots \\times (n-m+1)}{1 \\times 2 \\times 3 \\times 4 \\times \\cdots \\times m} = \\frac{n!}{m!(n-m)!}$$ 逆序对$A[1 \\ldots n]$如有$i \\lt j$且$A[i] \\gt A[j]$则称为逆序对。 模运算$$(a \\times b) \\bmod p = (a \\bmod p \\times b \\bmod p) \\bmod p$$ $$(a+b) \\bmod p = (a \\bmod p + b \\bmod p) \\bmod p$$ $$(a-b) \\bmod p = (a \\bmod p - b \\bmod p) \\bmod p$$ $$(a^b \\bmod p) = ((a \\bmod p) ^ b) \\bmod p$$ $$((a+b) \\bmod p + c) \\bmod p = (a + (b+c) \\bmod p) \\bmod p$$ $$((a+b) \\bmod p \\times c) \\bmod p = ((a \\times c) \\bmod p + (b \\times c) \\bmod p) \\bmod p$$ 二分查找mid = (l + r) / 2;等价于mid = l + (r - l) / 2。 第一种写法可能会爆int。 求最小值最大（最大值最小）一般使用二分答案来进行求解。 整数二分123456789int erfen(int l, int r) &#123; int mid; while (l &lt;= r) &#123; // 注意二分条件 mid = (l+r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 实数二分123456789double erfen(double l, double r) &#123; // dlt = 0.001(精度) double mid; while (fabs(l-r) &gt; dlt) &#123; mid = (l+r) / 2.0; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 数据结构堆Min-heap: 父节点的值小于或等于子节点的值。 Max-heap: 父节点的值大于或等于子节点的值。 STL upper_bound找到第一个大于x的数。 lower_bound找到第一个大于等于x的数。 greater&lt;int&gt;()降序排列。 less&lt;int&gt;()升序排列。 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;优先队列（大根堆）。 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap;优先队列（小根堆）。 next_permutation(a, a+n)生成a的全排列。 12345do &#123; for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\\n&quot;);&#125; while (next_permutation(a, a + n); 小技巧 scanf(&quot; %c&quot;, &amp;n)其中%c前面加一个空格可以过滤掉一切的空格，回车以及Tab，如果没有的话则不影响。 函数有返回值而不返回或者数组下标越界可能会产生各种奇怪的问题，比如C++11能AC但是C++14会RE等等。 用memset给int赋值为0x7f即为近似最大值，二进制位为0111 0111 0111 0111。 有向无环图的单源点最短路使用BFS算法最佳。 思考搜索究竟解决的是一个什么问题？ 在某一个空间里寻找目标。 空间指的是解空间。 目标指的是目标状态。 解空间：如果把一个问题的解抽象成一个数学上的向量，那么包含这个向量的空间，就是解空间。 目标状态：用于描述问题或者问题的解的一些量（我是谁？我在哪？）。 (有助于理解动态规划?) 判断N是否是质数，为什么判断到根号n就可以了？以下内容摘自知乎。 首先，约数是成对出现的。比如24，你找到个约数3，那么一定有个约数8，因为24/3=8。 然后，这对约数必须一个在根号n之前，一个在根号n之后。因为都在根号n之前的话，乘积一定小于n（根号nX根号n=n），同样，都在根号n之后的话，乘积一定大于n。 所以，如果你在根号n之前都找不到约数的话，那么根号n之后就不会有了。","categories":[{"name":"算法竞赛-笔记","slug":"algorithm-note","permalink":"https://blog.luoling8192.top/categories/algorithm-note/"}],"tags":[{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"二叉树","slug":"binary-tree","permalink":"https://blog.luoling8192.top/tags/binary-tree/"},{"name":"初赛","slug":"preliminary-contest","permalink":"https://blog.luoling8192.top/tags/preliminary-contest/"},{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"STL","slug":"STL","permalink":"https://blog.luoling8192.top/tags/STL/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】USACO 愤怒的牛","slug":"题解-USACO-愤怒的牛","date":"2020-08-29T09:55:00.000Z","updated":"2020-08-31T10:14:06.260Z","comments":true,"path":"/posts/algorithm-solution/usaco-the-angry-bull.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/usaco-the-angry-bull.html","excerpt":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？","text":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* P10011 愤怒的牛 * 来源: 信息学奥赛一本通 提高篇 * 作者: RainbowBird * 日期: 2020-08-29 * 算法: 二分答案 */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;int&gt; a;int check(int x) &#123; int last = a[0]; // 先塞第一个牛棚 int count = 1; // 遍历区间 for (auto it = a.begin() + 1; it != a.end(); it++) &#123; // 如果当前的牛棚和上一个牛棚的距离大于或等于最大值 if (*it - last &gt;= x) &#123; last = *it; count++; &#125; // 如果可以把牛全部放进牛棚 if (count &gt;= m) return true; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; a.push_back(x); &#125; sort(a.begin(), a.end(), less&lt;int&gt;()); // [l, r]为闭区间 int l = a[0], r = a[n-1]; // l, r, mid都为距离 while (l &lt;= r) &#123; int mid = (l + r) / 2; // mid为最短距离的最大值 if (check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; r &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.luoling8192.top/tags/USACO/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】NOIP2000 进制转换","slug":"题解-NOIP2000-进制转换","date":"2020-08-28T04:25:39.000Z","updated":"2020-08-31T10:08:21.484Z","comments":true,"path":"/posts/algorithm-solution/noip2000-sys-convert.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2000-sys-convert.html","excerpt":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。","text":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。 十进制转二进制的代码如下： 12345int binary[255], cur = 0;while (n &gt; 0) &#123; binary[++cur] = n % m; n /= m;&#125; 其中n为十进制下的数字，m为需要转换的进制。 那么当目标进制为负数的时候要注意什么呢？ 余数不能为负数。 例如，$(19)_{10}$要转换成$-9$进制。 $19/-9=-2…1$ $-2/-9=1…7$（注意这里不是$0...-2$！因为负数不能做余数。） $1/-9=0…1$（当商为0时计算完成） 代码实现1234567891011121314151617181920212223242526272829303132333435/* P1017 进制转换 * 来源: NOIP2000 * 作者: RainbowBird * 日期: 2020-08-28 * 算法: 负进制转换 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;char nums[20] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;&#125;;int main() &#123; int n, r; scanf(&quot;%d %d&quot;, &amp;n, &amp;r); printf(&quot;%d=&quot;, n); char ans[10005], cur = 0; while (n != 0) &#123; // 注意这里是不等于，因为商可能为负数 int mod = n % r; // 获取余数 n /= r; // 获取商 // 如果余数小于0，那么商进一位，余数则等于进制数的绝对值减去余数的绝对值 if (mod &lt; 0) n++, mod = abs(r) - abs(mod); ans[cur++] = nums[mod]; &#125; // 由高位到低位倒序输出 for (int i = cur - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, ans[i]); printf(&quot;(base%d)\\n&quot;, r); return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】双向BFS","slug":"模板-双向BFS","date":"2020-08-26T10:57:00.000Z","updated":"2020-08-31T10:16:03.856Z","comments":true,"path":"/posts/algorithm-template/tamplate-twophase-bfs.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/tamplate-twophase-bfs.html","excerpt":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。","text":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。 输入样例： 1234565 5..####....#.#.##.#.##.#.. 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;char a[55][55];int nextn[4][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;int dis[55][55], vst[55][55];struct Node &#123; int x, y;&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(a, 0, sizeof(a)); memset(dis, 0, sizeof(dis)); memset(vst, 0, sizeof(vst)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; queue&lt;Node&gt; que1; // 向前搜 queue&lt;Node&gt; que2; // 向后搜 // vst标记状态 dis表示路程 que1.push(Node&#123;1, 1&#125;), dis[1][1] = 1, vst[1][1] = 1; que2.push(Node&#123;n, m&#125;), dis[n][m] = 1, vst[n][m] = 2; while (!que1.empty() &amp;&amp; !que2.empty()) &#123; int flag; Node head; if (que1.size() &gt; que2.size()) &#123; // 哪个队列元素少就从哪个队列开始搜 head = que2.front(); // 向前搜 que2.pop(); flag = 2; &#125; else &#123; head = que1.front(); // 向后搜 que1.pop(); flag = 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; int tx = head.x + nextn[i][0]; int ty = head.y + nextn[i][1]; if (tx &gt; n || ty &gt; m || tx &lt;= 0 || ty &lt;= 0) continue; if (a[tx][ty] == &#x27;.&#x27;) &#123; if (!dis[tx][ty]) &#123; // 这一步没有队列走过 dis[tx][ty] = dis[head.x][head.y] + 1; // 路程加一 vst[tx][ty] = vst[head.x][head.y]; // 继承状态 if (flag == 1) que1.push(Node&#123;tx, ty&#125;); else if (flag == 2) que2.push(Node&#123;tx, ty&#125;); &#125; else if (vst[head.x][head.y] + vst[tx][ty] == 3) &#123; // 如果相遇 cout &lt;&lt; dis[head.x][head.y] + dis[tx][ty] &lt;&lt; endl; // 步数相加 return 0; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】NOIP2003 乒乓球","slug":"题解-NOIP2003-乒乓球","date":"2020-08-23T09:58:38.000Z","updated":"2020-08-31T10:14:23.957Z","comments":true,"path":"/posts/algorithm-solution/noip2003-table-tennis.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2003-table-tennis.html","excerpt":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0","text":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0 具体请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* P1217 乒乓球 * 作者: RainbowBird * 日期: 2020-08-18 * 算法: 模拟 */#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, game[25 * 2500 + 5];int main() &#123; // 读入数据 memset(game, 0, sizeof(game)); char ch = getchar(); while (ch != &#x27;E&#x27;) &#123; if (ch == &#x27;W&#x27;) game[++n] = 1; else if (ch == &#x27;L&#x27;) game[++n] = 2; ch = getchar(); &#125; if (n == 0) n = 1; // 11分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 11 || b &gt;= 11) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; printf(&quot;\\n&quot;); // 21分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 21 || b &gt;= 21) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"},{"name":"字符串","slug":"string","permalink":"https://blog.luoling8192.top/tags/string/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】高精度模板","slug":"模板-高精度模板","date":"2020-08-23T09:57:15.000Z","updated":"2020-08-31T10:10:36.321Z","comments":true,"path":"/posts/algorithm-template/high-precision-template.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/high-precision-template.html","excerpt":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。","text":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。 高精度加法1234567891011121314151617181920212223242526string add(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] + nb[i]; if (nc[i] &gt;= 10) &#123; nc[i+1]++; nc[i] -= 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度减法1234567891011121314151617181920212223242526string sub(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] - nb[i]; if (nc[i] &lt; 0) &#123; nc[i+1]--; nc[i] += 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度乘法123456789101112131415161718192021222324252627282930313233string mul(string a, string b) &#123; int na[105], nb[105], nc[10005]; int lena = a.length(), lenb = b.length(); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena; i++) &#123; for (int j = 1; j &lt;= lenb; j++) &#123; nc[i+j-1] += na[i] * nb[j]; &#125; &#125; for (int i = 1; i &lt; lena + lenb; i++) &#123; if (nc[i] &gt;= 10) &#123; nc[i+1] += nc[i] / 10; nc[i] %= 10; &#125; &#125; int lenc = lena + lenb + 1; while (nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度除法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int cmp(int a[], int b[], int last, int len) &#123; if (a[last+len] != 0) return true; // 如果被除数的位数比除数大 // 逐位比较 for (int i = len; i &gt; 0; i--) &#123; if (a[i+last-1] &gt; b[i]) return true; if (a[i+last-1] &lt; b[i]) return false; &#125; // 相等返回true return true;&#125;void div(string a, string b) &#123; // 声明变量 int lena = a.length(), lenb = b.length(), lenc = lena - lenb + 2, lend = max(lena, lenb) + 1; // 清空变量 memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); // 商 memset(nd, 0, sizeof(nd)); // 余数 // 把数字倒过来存 for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;, nd[i] = na[i]; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; //for (int i = 1; i &lt;= lena; i++) nd[i] = na[i]; // 存余数 // 高精度除法 for (int i = lena - lenb + 1; i &gt; 0; i--) &#123; // 被除数和除数对齐 /* 456 / 12 * 38 * 12 |---- * 456 * 36 * ---- * 96 * 96 * ---- * 0 */ // 可以相减 while (cmp(nd, nb, i, lenb)) &#123; // 高精度减法 for (int j = 1; j &lt;= lenb; j++) &#123; nd[i+j-1] -= nb[j]; if (nd[i+j-1] &lt; 0) &#123; nd[i+j]--; nd[i+j-1] += 10; &#125; &#125; nc[i]++; // 商进一位 &#125; &#125; // 输出商 while (nc[--lenc] == 0); if (lenc &lt;= 0) lenc++; for (int i = lenc; i &gt; 0; i--) &#123; cout &lt;&lt; nc[i]; &#125; cout &lt;&lt; endl; // 输出余数 while (nd[--lend] == 0); if (lend &lt;= 0) lend++; for (int i = lend; i &gt; 0; i--) &#123; cout &lt;&lt; nd[i]; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}],"author":[{"name":"RainbowBird"}]}],"categories":[{"name":"算法竞赛-笔记","slug":"algorithm-note","permalink":"https://blog.luoling8192.top/categories/algorithm-note/"},{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"},{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"动态规划","slug":"DP","permalink":"https://blog.luoling8192.top/tags/DP/"},{"name":"背包","slug":"backpack","permalink":"https://blog.luoling8192.top/tags/backpack/"},{"name":"线段树","slug":"segment-tree","permalink":"https://blog.luoling8192.top/tags/segment-tree/"},{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"字典树","slug":"trie-tree","permalink":"https://blog.luoling8192.top/tags/trie-tree/"},{"name":"离散化","slug":"discretized","permalink":"https://blog.luoling8192.top/tags/discretized/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://blog.luoling8192.top/tags/prefix-sum/"},{"name":"倍增","slug":"redouble","permalink":"https://blog.luoling8192.top/tags/redouble/"},{"name":"快速幂","slug":"quick-pow","permalink":"https://blog.luoling8192.top/tags/quick-pow/"},{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"二叉树","slug":"binary-tree","permalink":"https://blog.luoling8192.top/tags/binary-tree/"},{"name":"初赛","slug":"preliminary-contest","permalink":"https://blog.luoling8192.top/tags/preliminary-contest/"},{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"STL","slug":"STL","permalink":"https://blog.luoling8192.top/tags/STL/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.luoling8192.top/tags/USACO/"},{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"},{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"},{"name":"字符串","slug":"string","permalink":"https://blog.luoling8192.top/tags/string/"},{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}]}