{"meta":{"title":"洛灵酱的小窝","subtitle":"想要变可爱","description":"以梦为马，不负韶华。","author":"RainbowBird","url":"https://blog.luoling8192.top","root":"/"},"pages":[{"title":"关于","date":"2020-08-21T11:05:34.000Z","updated":"2020-08-29T07:39:06.450Z","comments":true,"path":"about/index.html","permalink":"https://blog.luoling8192.top/about/","excerpt":"","text":".tag { display: inline-block; color: #333; box-sizing: border-box; border-radius: 2px; padding: 10px; margin: 6px 0; background: #f3f3f3; text-decoration: none; transition: all .25s; -webkit-transition: all .25s; cursor: default; } .tag:hover { background: rgba(0, 0, 0, 0.1); box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; -webkit-box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; } 关于我MtF / INFP / OIer一只为了成为自己喜欢的样子而努力奋斗的小木桶饭。目前在阿卡林省读高一，是一个很菜的OIer（枯。 2020年8月22日之前的博客在博客园可以找到。 这里有我AC的习题代码。 竞赛学习进度 标签 INFP 想变得可爱 木桶饭 程序媛 技术栈会点前端 HTML/CSS Javascript Vue 会点后端 NodeJS PHP Python 联系方式快来找我一起玩吖www 各大OJ 洛谷：RainbowBird 牛客：洛灵酱爱次糖 UOJ：luoling8192 LOJ：luoling8192 CodeForces：RainbowBird 社交账号 QQ：1284114089 邮箱：rbxin2003@outlook.com 知乎：秋山雪奈 哔哩哔哩：洛灵酱爱次糖 新浪微博：洛灵酱爱次糖 Github：RainbowBird Gitee：秋山雪奈酱"},{"title":"分类","date":"2020-08-27T03:28:03.591Z","updated":"2020-08-27T03:28:03.596Z","comments":false,"path":"categories/index.html","permalink":"https://blog.luoling8192.top/categories/","excerpt":"","text":""},{"title":"","date":"2020-08-31T01:05:49.327Z","updated":"2020-08-31T01:05:49.329Z","comments":true,"path":"css/user.css","permalink":"https://blog.luoling8192.top/css/user.css","excerpt":"","text":"html{font-family:\"Segoe UI\",\"PingFang SC\",\"Microsoft YaHei\",Helvetica,Arial,sans-serif!important;text-shadow:rgba(0,0,0,.8) 0 0 0}.darkmode-layer,.darkmode-toggle{bottom:90px!important}.github-corner svg{position:fixed!important}a[href]{transition:all .1s ease-out;position:relative;box-sizing:content-box}a[href]:hover:not([class*=tag]){color:#ff6c6c!important}.article-title a[href]:hover{color:#555!important}.article-title a[href]::after{content:'';transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s;position:absolute;background:#555;bottom:0;left:0;height:2px;width:100%;visibility:hidden;transform:scaleX(0)}.article-title a[href]:hover::after{visibility:visible;transform:scaleX(1)}.post-tags *{font-size:.875rem}.post-tags a{color:#888;transition:all .1s ease-out}.post-tags a:hover{color:#ff6c6c!important}"},{"title":"好朋友们","date":"2020-08-27T03:43:11.000Z","updated":"2020-08-29T08:14:56.597Z","comments":true,"path":"friends/index.html","permalink":"https://blog.luoling8192.top/friends/","excerpt":"","text":"欢迎在评论区留言互换友链(〃’▽’〃) 大佬 TURX Kal0rona"},{"title":"","date":"2020-08-27T02:56:45.136Z","updated":"2020-08-27T02:56:45.137Z","comments":true,"path":"js/fireworks.js","permalink":"https://blog.luoling8192.top/js/fireworks.js","excerpt":"","text":"\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t"},{"title":"","date":"2020-08-27T03:06:59.429Z","updated":"2020-08-27T03:06:59.434Z","comments":true,"path":"js/funnytitle.js","permalink":"https://blog.luoling8192.top/js/funnytitle.js","excerpt":"","text":"// 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω"},{"title":"相册","date":"2020-08-29T09:25:22.000Z","updated":"2020-08-29T10:09:02.286Z","comments":true,"path":"photos/index.html","permalink":"https://blog.luoling8192.top/photos/","excerpt":"","text":"2020-08-03"},{"title":"目前进度","date":"2020-08-28T05:21:41.000Z","updated":"2020-08-28T07:45:01.219Z","comments":true,"path":"progress/index.html","permalink":"https://blog.luoling8192.top/progress/","excerpt":"","text":"一级标准 程序的基本结构 标识符和关键字 程序的基本结构 标识符和关键字 基本数据类型 常量和变量 算术表达式和关系表达式 整除，求余运算，常用数学函数 赋值语句，输入输出语句，复合语句，条件语句（不嵌套），循环语句（不嵌套） 二级标准 逻辑表达式 条件嵌套，循环嵌套，数组 枚举，简单排序，简单查找算法 素数与合数，最大公约数，最小公倍数，互质数 三级标准 数制及其转化，信息编码，位运算 字符串类型 子程序 递归 逻辑运算，整数的质因数分解，随机函数 筛选法，欧几里得算法 四级标准 结构类型，文件操作 数据类型的内在含义 贪心法，递推，回溯法，模拟算法 简单的字符串处理 集合及集合的运算，加法原理和乘法原理，简单的排列和组合 五级标准 指针类型 一般线性表，队列，堆栈，二叉树的存储和遍历 排列和组合，高精度数值的处理 二分算法，快速排序，深度优先搜索，宽度优先搜索，简单动态规划 圆排列，可重集排列，鸽笼原理，素因数分解，幂函数，指数函数，对数函数，三角函数，模运算，不等式基础知识 六级标准 树、图的存储 哈希表、集合数据结构 图的最短路，生成树算法，有向图的拓扑排序算法 动态规划的常见模型，分治策略，各种排序算法 可重集组合，二项式定理，数列与级数，归纳与递推，容斥原理，函数的连续性、函数的单调性和极值 七级标准 并查集，线段树，哈弗曼树，二叉排序树，二叉堆 图的连通性算法，最短路，最小生成树的优化算法，二分图的构造、判定及匹配，搜索算法的优化，扩展欧几里得算法 中国剩余定理，剩余类，概率基础知识，解析几何基础知识 八级标准 树状数组，字典树，优先队列，平衡树 网络流算法，复杂的分治思想，树形动态规划，状态压缩动态规划，二分图的匹配，启发式搜索 矩阵概念及其基本运算，线性方程组的解法，迭代法，费马小定理和欧拉定理，母函数 九级标准 块状链表，后缀数组，后缀树，复杂的线段树 动态规划优化，模拟退火算法 计算几何基础知识（点积、叉积、凸包、半平面等知识及应用），数学期望 十级标准 最小树形图，自动机，动态树，树套树，一般图的匹配 双重动态规划，基于连通性的动态规划，线性规划，极大极小搜索算法 三维计算几何，组合游戏中的NIM问题和SG函数，群的概念，置换群，Burnside引理，Polya原理，莫比乌斯反演定理，FFT"},{"title":"说说","date":"2020-08-27T03:13:55.000Z","updated":"2020-08-27T03:29:23.013Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://blog.luoling8192.top/shuoshuo/","excerpt":"","text":""},{"title":"标签","date":"2020-08-27T03:28:09.071Z","updated":"2020-08-27T03:28:09.078Z","comments":false,"path":"tags/index.html","permalink":"https://blog.luoling8192.top/tags/","excerpt":"","text":""}],"posts":[{"title":"【模板】字典树","slug":"模板-字典树","date":"2020-08-31T09:49:05.000Z","updated":"2020-08-31T13:39:29.501Z","comments":true,"path":"/posts/algorithm-template/trie-tree.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/trie-tree.html","excerpt":"什么是字典树 原理在这篇文章中讲的很清楚了，非常感谢。","text":"什么是字典树 原理在这篇文章中讲的很清楚了，非常感谢。 为什么要用字典树Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 代码实现1234567891011121314151617181920212223242526int trie[10005][26]; // 最大深度 最大字符集int book[10005]; // 用于标识是否为终结点int cur = 1; // 从1开始因为0是根节点void insert(string str) &#123; int p = 0; // 从根节点开始遍历 for (int i = 0; i &lt; str.length(); i++) &#123; int c = str[i] - &#x27;a&#x27;; // 把小写字母转换为数字（从0-25，分别对应a-z） if (!trie[p][c]) // 如果当前节点没有一条为c的边 trie[p][c] = cur++; // 添加一条边，边总数加1 p = trie[p][c]; // 指针移到当前节点 &#125; book[p] = 1; // 遍历完成，在最后一条边上打上结束标记&#125;int search(string str) &#123; int p = 0; for (int i = 0; i &lt; str.length(); i++) &#123; int c = str[i] - &#x27;a&#x27;; if (!trie[p][c]) return false; // 如果当前字母的边没有找到则返回false p = trie[p][c]; // 指针指向当前节点 &#125; return book[p] == 1; // 如果当前边有结束标记则说明找到了&#125; 简单写完main函数就完成了一个字典树的demo。 123456789101112131415161718int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; string a; cin &gt;&gt; a; insert(a); &#125; for (int i = 0; i &lt; m; i++) &#123; string a; cin &gt;&gt; a; if (search(a)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 运行效果","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"字典树","slug":"trie-tree","permalink":"https://blog.luoling8192.top/tags/trie-tree/"}]},{"title":"【题解】NOIP2005 校门外的树（离散化实现）","slug":"题解-NOIP2005-校门外的树-离散化实现","date":"2020-08-30T14:03:45.000Z","updated":"2020-08-31T10:13:48.613Z","comments":true,"path":"/posts/algorithm-solution/noip2005-school-tree.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2005-school-tree.html","excerpt":"题目链接P1047 校门外的树 今天用这道题目来练习一下离散化。 当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。","text":"题目链接P1047 校门外的树 今天用这道题目来练习一下离散化。 当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。 题目代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node &#123; int pos; // 位置 int num; // 前缀和&#125; a[100005];int cmp(Node a, Node b) &#123; return a.pos &lt; b.pos;&#125;int l, m;int main() &#123; cin &gt;&gt; l &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; // 离散化存储 a[i*2-1].pos = x; // 左端点的位置 a[i*2-1].num = 1; // 左端点用1表示 a[i*2].pos = y + 1; // 右端点的位置（差分用，所以这里是y+1） a[i*2].num = -1; // 右端点用-1表示 &#125; sort(a + 1, a + m * 2 + 1, cmp); // 按照左端点的位置升序排列 // 前缀和 int sum = 0, total = 0; for (int i = 1; i &lt;= m * 2; i++) &#123; // 一共有2m个点，全部遍历一遍 sum += a[i].num; // sum用来存储当前状态 // 当sum的值由0变为1时说明中间经过了一段没有树的区间 if (sum == 1 &amp;&amp; a[i].num == 1) &#123; // 这时a[i]是左端点，a[i-1]是上个区间的右端点 total += a[i].pos - a[i-1].pos; // 加上区间长度 &#125; &#125; // 最后一个右端点到区间终点的距离 total += l - a[m*2].pos + 1; cout &lt;&lt; total &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"离散化","slug":"discretized","permalink":"https://blog.luoling8192.top/tags/discretized/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://blog.luoling8192.top/tags/prefix-sum/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】快速幂","slug":"模板-快速幂","date":"2020-08-30T11:27:01.000Z","updated":"2020-08-31T10:17:06.616Z","comments":true,"path":"/posts/algorithm-template/template-quick-pow.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/template-quick-pow.html","excerpt":"今天学了倍增，终于把非递归快速幂看懂了。","text":"今天学了倍增，终于把非递归快速幂看懂了。 还是把$a^n$拆分成二进制形式。 例如：$$a^{10} = a^{(1010) _ 2} = a^{1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0} = a^{1 * 2^3} * a^{1 * 2^1}$$ 我们可以通过倍增的方法先计算$\\mod p$意义下的$a^1$，$a^2$，$a^4$，$a^8$，$a^{16}$，$a^{32}$，再把它们根据$b$的二进制拆分乘起来。 下面请看代码实现： 123456789101112// a ^ b % pint quick_pow(int a, int b, int p) &#123; int t = a; // 倍增（a^1 a^2 a^3 ...） int ans = 1; while (b &gt; 0) &#123; if (b &amp; 1) // 二进制最后一位是1 ans = (ans * t) % p; t = (t * t) % p; b &gt;&gt;= 1; // 计算下一个二进制的值 &#125; return ans;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"倍增","slug":"redouble","permalink":"https://blog.luoling8192.top/tags/redouble/"},{"name":"快速幂","slug":"quick-pow","permalink":"https://blog.luoling8192.top/tags/quick-pow/"}],"author":[{"name":"RainbowBird"}]},{"title":"算法学习笔记","slug":"算法学习笔记","date":"2020-08-29T11:20:25.000Z","updated":"2020-08-31T10:15:03.622Z","comments":true,"path":"/posts/algorithm-note/algorithmic-learning-notes.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-note/algorithmic-learning-notes.html","excerpt":"蒟蒻的学习笔记，时不时拿出来看一看。","text":"蒟蒻的学习笔记，时不时拿出来看一看。 数论gcd 最大公约数 辗转相除法，更相减损法 123456789int gcd(int a, int b) &#123; int mod; while(b &gt; 0) &#123; mod = a % b; a = b; b = mod; &#125; return a;&#125; lcm 最小公倍数123int lcm(int a, b) &#123; return a * b / gcd(a, b);&#125; 互质数互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。 斐波那契数列 1 1 2 3 5 8 13 21 $f(1)=1$$f(2)=1$$f(3)=f(1)+f(2)=f(3-2)+f(3-1)$$f(n)=f(n-2)+f(n-1)$ 卡特兰数 $f(0)=1$$f(1)=1$$f(n)=f(0)*f(n-1)+f(1)*f(n-2)…+f(n)*f(0)$ 应用：长度为n的栈一共有多少种出栈的方法。 二叉树前序遍历：根左右中序遍历：左根右后序遍历：左右根 初赛知识点位运算异或相同为0，不同为1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#96;&#96;&#96;n^1&#96;&#96;&#96;取反#### 补码源码的绝对值取反加1。### 运算顺序赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算数运算符### 排列组合![](https:&#x2F;&#x2F;rainbowbird.oss-cn-beijing.aliyuncs.com&#x2F;posts&#x2F;%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;3.png)#### 全排列$$A^m_n&#x3D;n * (n-1) * (n-2) * ... * (n-m+1) &#x3D; \\frac&#123;n!&#125;&#123;(n-m)!&#125;$$#### 全组合$$C^m_n&#x3D; \\frac&#123;A^m_n&#125;&#123;A^m_m&#125; &#x3D; \\frac&#123;n * (n-1) * (n-2) * ... * (n-m+1)&#125;&#123;1 * 2 * 3 * 4 * ... * m&#125; &#x3D; \\frac&#123;n!&#125;&#123;m!(n-m)!&#125;$$### 逆序对$A[1...n]$如有$i&lt;j$且$A[i]&gt;A[j]$则称为逆序对。### 模运算$(a * b) \\% p &#x3D; (a \\% p * b \\% p) \\% p$$(a + b) \\% p &#x3D; (a \\% p + b \\% p) \\% p$$(a - b) \\% p &#x3D; (a \\% p - b \\% p) \\% p$$(a ^ b \\% p) &#x3D; ((a \\% p) ^ b) \\% p$$((a+b) \\% p + c) \\% p &#x3D; (a + (b+c) \\% p) \\% p$$((a+b) \\% p * c) \\% p &#x3D; ((a * c) \\% p + (b * c) \\% p) \\% p$## 二分查找&#96;&#96;&#96;mid &#x3D; (l + r) &#x2F; 2;&#96;&#96;&#96;等价于&#96;&#96;&#96;mid &#x3D; l + (r - l) &#x2F; 2&#96;&#96;&#96;。第一种写法可能会爆&#96;&#96;&#96;int&#96;&#96;&#96;。**求最小值最大（最大值最小）一般使用二分答案来进行求解**。### 整数二分&#96;&#96;&#96;cppint erfen(int l, int r) &#123; int mid; while (l &lt;&#x3D; r) &#123; &#x2F;&#x2F; 注意二分条件 mid &#x3D; (l+r) &#x2F; 2; if (check(mid)) r &#x3D; mid; else l &#x3D; mid; &#125; return l;&#125; 实数二分123456789double erfen(double l, double r) &#123; // dlt = 0.001(精度) double mid; while (fabs(l-r) &gt; dlt) &#123; mid = (l+r) / 2.0; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 数据结构堆Min-heap: 父节点的值小于或等于子节点的值。Max-heap: 父节点的值大于或等于子节点的值。 STL upper_bound找到第一个大于x的数。 lower_bound找到第一个大于等于x的数。 greater&lt;int&gt;()降序排列。 less&lt;int&gt;()升序排列。 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;优先队列（大根堆）。 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap;优先队列（小根堆）。","categories":[{"name":"算法竞赛-笔记","slug":"algorithm-note","permalink":"https://blog.luoling8192.top/categories/algorithm-note/"}],"tags":[{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"二叉树","slug":"binary-tree","permalink":"https://blog.luoling8192.top/tags/binary-tree/"},{"name":"初赛","slug":"preliminary-contest","permalink":"https://blog.luoling8192.top/tags/preliminary-contest/"},{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"STL","slug":"STL","permalink":"https://blog.luoling8192.top/tags/STL/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】USACO 愤怒的牛","slug":"题解-USACO-愤怒的牛","date":"2020-08-29T09:55:00.000Z","updated":"2020-08-31T10:14:06.260Z","comments":true,"path":"/posts/algorithm-solution/usaco-the-angry-bull.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/usaco-the-angry-bull.html","excerpt":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？","text":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* P10011 愤怒的牛 * 来源: 信息学奥赛一本通 提高篇 * 作者: RainbowBird * 日期: 2020-08-29 * 算法: 二分答案 */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;int&gt; a;int check(int x) &#123; int last = a[0]; // 先塞第一个牛棚 int count = 1; // 遍历区间 for (auto it = a.begin() + 1; it != a.end(); it++) &#123; // 如果当前的牛棚和上一个牛棚的距离大于或等于最大值 if (*it - last &gt;= x) &#123; last = *it; count++; &#125; // 如果可以把牛全部放进牛棚 if (count &gt;= m) return true; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; a.push_back(x); &#125; sort(a.begin(), a.end(), less&lt;int&gt;()); // [l, r]为闭区间 int l = a[0], r = a[n-1]; // l, r, mid都为距离 while (l &lt;= r) &#123; int mid = (l + r) / 2; // mid为最短距离的最大值 if (check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; r &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.luoling8192.top/tags/USACO/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】NOIP2000 进制转换","slug":"题解-NOIP2000-进制转换","date":"2020-08-28T04:25:39.000Z","updated":"2020-08-31T10:08:21.484Z","comments":true,"path":"/posts/algorithm-solution/noip2000-sys-convert.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2000-sys-convert.html","excerpt":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。","text":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。 十进制转二进制的代码如下： 12345int binary[255], cur = 0;while (n &gt; 0) &#123; binary[++cur] = n % m; n /= m;&#125; 其中n为十进制下的数字，m为需要转换的进制。 那么当目标进制为负数的时候要注意什么呢？ 余数不能为负数。 例如，$(19)_{10}$要转换成$-9$进制。 $19/-9=-2…1$ $-2/-9=1…7$（注意这里不是$0...-2$！因为负数不能做余数。） $1/-9=0…1$（当商为0时计算完成） 代码实现1234567891011121314151617181920212223242526272829303132333435/* P1017 进制转换 * 来源: NOIP2000 * 作者: RainbowBird * 日期: 2020-08-28 * 算法: 负进制转换 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;char nums[20] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;&#125;;int main() &#123; int n, r; scanf(&quot;%d %d&quot;, &amp;n, &amp;r); printf(&quot;%d=&quot;, n); char ans[10005], cur = 0; while (n != 0) &#123; // 注意这里是不等于，因为商可能为负数 int mod = n % r; // 获取余数 n /= r; // 获取商 // 如果余数小于0，那么商进一位，余数则等于进制数的绝对值减去余数的绝对值 if (mod &lt; 0) n++, mod = abs(r) - abs(mod); ans[cur++] = nums[mod]; &#125; // 由高位到低位倒序输出 for (int i = cur - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, ans[i]); printf(&quot;(base%d)\\n&quot;, r); return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】双向BFS","slug":"模板-双向BFS","date":"2020-08-26T10:57:00.000Z","updated":"2020-08-31T10:16:03.856Z","comments":true,"path":"/posts/algorithm-template/tamplate-twophase-bfs.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/tamplate-twophase-bfs.html","excerpt":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。","text":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。 输入样例： 1234565 5..####....#.#.##.#.##.#.. 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;char a[55][55];int nextn[4][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;int dis[55][55], vst[55][55];struct Node &#123; int x, y;&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(a, 0, sizeof(a)); memset(dis, 0, sizeof(dis)); memset(vst, 0, sizeof(vst)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; queue&lt;Node&gt; que1; // 向前搜 queue&lt;Node&gt; que2; // 向后搜 // vst标记状态 dis表示路程 que1.push(Node&#123;1, 1&#125;), dis[1][1] = 1, vst[1][1] = 1; que2.push(Node&#123;n, m&#125;), dis[n][m] = 1, vst[n][m] = 2; while (!que1.empty() &amp;&amp; !que2.empty()) &#123; int flag; Node head; if (que1.size() &gt; que2.size()) &#123; // 哪个队列元素少就从哪个队列开始搜 head = que2.front(); // 向前搜 que2.pop(); flag = 2; &#125; else &#123; head = que1.front(); // 向后搜 que1.pop(); flag = 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; int tx = head.x + nextn[i][0]; int ty = head.y + nextn[i][1]; if (tx &gt; n || ty &gt; m || tx &lt;= 0 || ty &lt;= 0) continue; if (a[tx][ty] == &#x27;.&#x27;) &#123; if (!dis[tx][ty]) &#123; // 这一步没有队列走过 dis[tx][ty] = dis[head.x][head.y] + 1; // 路程加一 vst[tx][ty] = vst[head.x][head.y]; // 继承状态 if (flag == 1) que1.push(Node&#123;tx, ty&#125;); else if (flag == 2) que2.push(Node&#123;tx, ty&#125;); &#125; else if (vst[head.x][head.y] + vst[tx][ty] == 3) &#123; // 如果相遇 cout &lt;&lt; dis[head.x][head.y] + dis[tx][ty] &lt;&lt; endl; // 步数相加 return 0; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】NOIP2003 乒乓球","slug":"题解-NOIP2003-乒乓球","date":"2020-08-23T09:58:38.000Z","updated":"2020-08-31T10:14:23.957Z","comments":true,"path":"/posts/algorithm-solution/noip2003-table-tennis.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-solution/noip2003-table-tennis.html","excerpt":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0","text":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0 具体请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* P1217 乒乓球 * 作者: RainbowBird * 日期: 2020-08-18 * 算法: 模拟 */#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, game[25 * 2500 + 5];int main() &#123; // 读入数据 memset(game, 0, sizeof(game)); char ch = getchar(); while (ch != &#x27;E&#x27;) &#123; if (ch == &#x27;W&#x27;) game[++n] = 1; else if (ch == &#x27;L&#x27;) game[++n] = 2; ch = getchar(); &#125; if (n == 0) n = 1; // 11分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 11 || b &gt;= 11) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; printf(&quot;\\n&quot;); // 21分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 21 || b &gt;= 21) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"},{"name":"字符串","slug":"string","permalink":"https://blog.luoling8192.top/tags/string/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】高精度模板","slug":"模板-高精度模板","date":"2020-08-23T09:57:15.000Z","updated":"2020-08-31T10:10:36.321Z","comments":true,"path":"/posts/algorithm-template/high-precision-template.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm-template/high-precision-template.html","excerpt":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。","text":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。 高精度加法1234567891011121314151617181920212223242526string add(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] + nb[i]; if (nc[i] &gt;= 10) &#123; nc[i+1]++; nc[i] -= 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度减法1234567891011121314151617181920212223242526string sub(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] - nb[i]; if (nc[i] &lt; 0) &#123; nc[i+1]--; nc[i] += 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度乘法123456789101112131415161718192021222324252627282930313233string mul(string a, string b) &#123; int na[105], nb[105], nc[10005]; int lena = a.length(), lenb = b.length(); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena; i++) &#123; for (int j = 1; j &lt;= lenb; j++) &#123; nc[i+j-1] += na[i] * nb[j]; &#125; &#125; for (int i = 1; i &lt; lena + lenb; i++) &#123; if (nc[i] &gt;= 10) &#123; nc[i+1] += nc[i] / 10; nc[i] %= 10; &#125; &#125; int lenc = lena + lenb + 1; while (nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度除法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int cmp(int a[], int b[], int last, int len) &#123; if (a[last+len] != 0) return true; // 如果被除数的位数比除数大 // 逐位比较 for (int i = len; i &gt; 0; i--) &#123; if (a[i+last-1] &gt; b[i]) return true; if (a[i+last-1] &lt; b[i]) return false; &#125; // 相等返回true return true;&#125;void div(string a, string b) &#123; // 声明变量 int lena = a.length(), lenb = b.length(), lenc = lena - lenb + 2, lend = max(lena, lenb) + 1; // 清空变量 memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); // 商 memset(nd, 0, sizeof(nd)); // 余数 // 把数字倒过来存 for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;, nd[i] = na[i]; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; //for (int i = 1; i &lt;= lena; i++) nd[i] = na[i]; // 存余数 // 高精度除法 for (int i = lena - lenb + 1; i &gt; 0; i--) &#123; // 被除数和除数对齐 /* 456 / 12 * 38 * 12 |---- * 456 * 36 * ---- * 96 * 96 * ---- * 0 */ // 可以相减 while (cmp(nd, nb, i, lenb)) &#123; // 高精度减法 for (int j = 1; j &lt;= lenb; j++) &#123; nd[i+j-1] -= nb[j]; if (nd[i+j-1] &lt; 0) &#123; nd[i+j]--; nd[i+j-1] += 10; &#125; &#125; nc[i]++; // 商进一位 &#125; &#125; // 输出商 while (nc[--lenc] == 0); if (lenc &lt;= 0) lenc++; for (int i = lenc; i &gt; 0; i--) &#123; cout &lt;&lt; nc[i]; &#125; cout &lt;&lt; endl; // 输出余数 while (nd[--lend] == 0); if (lend &lt;= 0) lend++; for (int i = lend; i &gt; 0; i--) &#123; cout &lt;&lt; nd[i]; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"}],"tags":[{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}],"author":[{"name":"RainbowBird"}]},{"title":"欢迎","slug":"欢迎","date":"2020-08-23T04:13:58.000Z","updated":"2020-08-31T10:16:48.505Z","comments":true,"path":"/posts/daily/welcome.html","link":"","permalink":"https://blog.luoling8192.top/posts/daily/welcome.html","excerpt":"欢迎来到我的博客！ 关于我 2020年8月22日之前的博客在博客园可以找到。","text":"欢迎来到我的博客！ 关于我 2020年8月22日之前的博客在博客园可以找到。","categories":[{"name":"日常","slug":"daily","permalink":"https://blog.luoling8192.top/categories/daily/"}],"tags":[],"author":[{"name":"RainbowBird"}]}],"categories":[{"name":"算法竞赛-模板","slug":"algorithm-template","permalink":"https://blog.luoling8192.top/categories/algorithm-template/"},{"name":"算法竞赛-题解","slug":"algorithm-solution","permalink":"https://blog.luoling8192.top/categories/algorithm-solution/"},{"name":"算法竞赛-笔记","slug":"algorithm-note","permalink":"https://blog.luoling8192.top/categories/algorithm-note/"},{"name":"日常","slug":"daily","permalink":"https://blog.luoling8192.top/categories/daily/"}],"tags":[{"name":"数据结构","slug":"data-structure","permalink":"https://blog.luoling8192.top/tags/data-structure/"},{"name":"字典树","slug":"trie-tree","permalink":"https://blog.luoling8192.top/tags/trie-tree/"},{"name":"离散化","slug":"discretized","permalink":"https://blog.luoling8192.top/tags/discretized/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://blog.luoling8192.top/tags/prefix-sum/"},{"name":"倍增","slug":"redouble","permalink":"https://blog.luoling8192.top/tags/redouble/"},{"name":"快速幂","slug":"quick-pow","permalink":"https://blog.luoling8192.top/tags/quick-pow/"},{"name":"数论","slug":"math","permalink":"https://blog.luoling8192.top/tags/math/"},{"name":"二叉树","slug":"binary-tree","permalink":"https://blog.luoling8192.top/tags/binary-tree/"},{"name":"初赛","slug":"preliminary-contest","permalink":"https://blog.luoling8192.top/tags/preliminary-contest/"},{"name":"二分查找","slug":"binary-search","permalink":"https://blog.luoling8192.top/tags/binary-search/"},{"name":"STL","slug":"STL","permalink":"https://blog.luoling8192.top/tags/STL/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.luoling8192.top/tags/USACO/"},{"name":"NOIP","slug":"NOIP","permalink":"https://blog.luoling8192.top/tags/NOIP/"},{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"},{"name":"字符串","slug":"string","permalink":"https://blog.luoling8192.top/tags/string/"},{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}]}