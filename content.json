{"meta":{"title":"洛灵酱的小窝","subtitle":"想要变可爱","description":"以梦为马，不负韶华。","author":"RainbowBird","url":"https://blog.luoling8192.top","root":"/"},"pages":[{"title":"关于","date":"2020-08-21T11:05:34.000Z","updated":"2020-08-29T07:39:06.450Z","comments":true,"path":"about/index.html","permalink":"https://blog.luoling8192.top/about/","excerpt":"","text":".tag { display: inline-block; color: #333; box-sizing: border-box; border-radius: 2px; padding: 10px; margin: 6px 0; background: #f3f3f3; text-decoration: none; transition: all .25s; -webkit-transition: all .25s; cursor: default; } .tag:hover { background: rgba(0, 0, 0, 0.1); box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; -webkit-box-shadow: rgba(0, 0, 0, 0.1) 0 5px 10px; } 关于我MtF / INFP / OIer一只为了成为自己喜欢的样子而努力奋斗的小木桶饭。目前在阿卡林省读高一，是一个很菜的OIer（枯。 2020年8月22日之前的博客在博客园可以找到。 这里有我AC的习题代码。 竞赛学习进度 标签 INFP 想变得可爱 木桶饭 程序媛 技术栈会点前端 HTML/CSS Javascript Vue 会点后端 NodeJS PHP Python 联系方式快来找我一起玩吖www 各大OJ 洛谷：RainbowBird 牛客：洛灵酱爱次糖 UOJ：luoling8192 LOJ：luoling8192 CodeForces：RainbowBird 社交账号 QQ：1284114089 邮箱：rbxin2003@outlook.com 知乎：秋山雪奈 哔哩哔哩：洛灵酱爱次糖 新浪微博：洛灵酱爱次糖 Github：RainbowBird Gitee：秋山雪奈酱"},{"title":"分类","date":"2020-08-27T03:28:03.591Z","updated":"2020-08-27T03:28:03.596Z","comments":false,"path":"categories/index.html","permalink":"https://blog.luoling8192.top/categories/","excerpt":"","text":""},{"title":"好朋友们","date":"2020-08-27T03:43:11.000Z","updated":"2020-08-29T08:14:56.597Z","comments":true,"path":"friends/index.html","permalink":"https://blog.luoling8192.top/friends/","excerpt":"","text":"欢迎在评论区留言互换友链(〃’▽’〃) 大佬 TURX Kal0rona"},{"title":"","date":"2020-08-27T02:56:45.136Z","updated":"2020-08-27T02:56:45.137Z","comments":true,"path":"js/fireworks.js","permalink":"https://blog.luoling8192.top/js/fireworks.js","excerpt":"","text":"\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t"},{"title":"","date":"2020-08-27T03:06:59.429Z","updated":"2020-08-27T03:06:59.434Z","comments":true,"path":"js/funnytitle.js","permalink":"https://blog.luoling8192.top/js/funnytitle.js","excerpt":"","text":"// 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω"},{"title":"说说","date":"2020-08-27T03:13:55.000Z","updated":"2020-08-27T03:29:23.013Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://blog.luoling8192.top/shuoshuo/","excerpt":"","text":""},{"title":"标签","date":"2020-08-27T03:28:09.071Z","updated":"2020-08-27T03:28:09.078Z","comments":false,"path":"tags/index.html","permalink":"https://blog.luoling8192.top/tags/","excerpt":"","text":""},{"title":"目前进度","date":"2020-08-28T05:21:41.000Z","updated":"2020-08-28T07:45:01.219Z","comments":true,"path":"progress/index.html","permalink":"https://blog.luoling8192.top/progress/","excerpt":"","text":"一级标准 程序的基本结构 标识符和关键字 程序的基本结构 标识符和关键字 基本数据类型 常量和变量 算术表达式和关系表达式 整除，求余运算，常用数学函数 赋值语句，输入输出语句，复合语句，条件语句（不嵌套），循环语句（不嵌套） 二级标准 逻辑表达式 条件嵌套，循环嵌套，数组 枚举，简单排序，简单查找算法 素数与合数，最大公约数，最小公倍数，互质数 三级标准 数制及其转化，信息编码，位运算 字符串类型 子程序 递归 逻辑运算，整数的质因数分解，随机函数 筛选法，欧几里得算法 四级标准 结构类型，文件操作 数据类型的内在含义 贪心法，递推，回溯法，模拟算法 简单的字符串处理 集合及集合的运算，加法原理和乘法原理，简单的排列和组合 五级标准 指针类型 一般线性表，队列，堆栈，二叉树的存储和遍历 排列和组合，高精度数值的处理 二分算法，快速排序，深度优先搜索，宽度优先搜索，简单动态规划 圆排列，可重集排列，鸽笼原理，素因数分解，幂函数，指数函数，对数函数，三角函数，模运算，不等式基础知识 六级标准 树、图的存储 哈希表、集合数据结构 图的最短路，生成树算法，有向图的拓扑排序算法 动态规划的常见模型，分治策略，各种排序算法 可重集组合，二项式定理，数列与级数，归纳与递推，容斥原理，函数的连续性、函数的单调性和极值 七级标准 并查集，线段树，哈弗曼树，二叉排序树，二叉堆 图的连通性算法，最短路，最小生成树的优化算法，二分图的构造、判定及匹配，搜索算法的优化，扩展欧几里得算法 中国剩余定理，剩余类，概率基础知识，解析几何基础知识 八级标准 树状数组，字典树，优先队列，平衡树 网络流算法，复杂的分治思想，树形动态规划，状态压缩动态规划，二分图的匹配，启发式搜索 矩阵概念及其基本运算，线性方程组的解法，迭代法，费马小定理和欧拉定理，母函数 九级标准 块状链表，后缀数组，后缀树，复杂的线段树 动态规划优化，模拟退火算法 计算几何基础知识（点积、叉积、凸包、半平面等知识及应用），数学期望 十级标准 最小树形图，自动机，动态树，树套树，一般图的匹配 双重动态规划，基于连通性的动态规划，线性规划，极大极小搜索算法 三维计算几何，组合游戏中的NIM问题和SG函数，群的概念，置换群，Burnside引理，Polya原理，莫比乌斯反演定理，FFT"},{"title":"相册","date":"2020-08-29T09:25:22.000Z","updated":"2020-08-29T09:30:54.605Z","comments":true,"path":"photos/index.html","permalink":"https://blog.luoling8192.top/photos/","excerpt":"","text":"2020-08-29"}],"posts":[{"title":"【题解】NOIP2000 进制转换","slug":"题解-NOIP2000-进制转换","date":"2020-08-28T04:25:39.000Z","updated":"2020-08-29T09:20:15.001Z","comments":true,"path":"/posts/algorithm/noip2000-sys-convert.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm/noip2000-sys-convert.html","excerpt":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。","text":"题目链接P1017 进制转换 题目分析这道题考察的是负进制转换。 我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。 十进制转二进制的代码如下： 12345int binary[255], cur = 0;while (n &gt; 0) &#123; binary[++cur] = n % m; n /= m;&#125; 其中n为十进制下的数字，m为需要转换的进制。 那么当目标进制为负数的时候要注意什么呢？ 余数不能为负数。 例如，$(19)_{10}$要转换成$-9$进制。 $19/-9=-2…1$ $-2/-9=1…7$（注意这里不是$0...-2$！因为负数不能做余数。） $1/-9=0…1$（当商为0时计算完成） 代码实现1234567891011121314151617181920212223242526272829303132333435/* P1017 进制转换 * 来源: NOIP2000 * 作者: RainbowBird * 日期: 2020-08-28 * 算法: 负进制转换 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;char nums[20] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;&#125;;int main() &#123; int n, r; scanf(&quot;%d %d&quot;, &amp;n, &amp;r); printf(&quot;%d=&quot;, n); char ans[10005], cur = 0; while (n != 0) &#123; // 注意这里是不等于，因为商可能为负数 int mod = n % r; // 获取余数 n /= r; // 获取商 // 如果余数小于0，那么商进一位，余数则等于进制数的绝对值减去余数的绝对值 if (mod &lt; 0) n++, mod = abs(r) - abs(mod); ans[cur++] = nums[mod]; &#125; // 由高位到低位倒序输出 for (int i = cur - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, ans[i]); printf(&quot;(base%d)\\n&quot;, r); return 0;&#125;","categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"}],"tags":[{"name":"题解","slug":"solution","permalink":"https://blog.luoling8192.top/tags/solution/"},{"name":"进制转换","slug":"sys-convert","permalink":"https://blog.luoling8192.top/tags/sys-convert/"}],"author":[{"name":"RainbowBird"}]},{"title":"【题解】USACO 愤怒的牛","slug":"题解-USACO-愤怒的牛","date":"2020-08-28T04:25:39.000Z","updated":"2020-08-29T09:40:10.979Z","comments":true,"path":"/posts/algorithm/usaco-the-angry-bull.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm/usaco-the-angry-bull.html","excerpt":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？","text":"题目链接「一本通 1.2 例 1」愤怒的牛 题目分析所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用check()函数来判断答案的可行性。 求最小值最大或求最大值最小是典型的二分答案。 要注意的是二分的边界。 推荐阅读：二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* P10011 愤怒的牛 * 来源: 信息学奥赛一本通 提高篇 * 作者: RainbowBird * 日期: 2020-08-29 * 算法: 二分答案 */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;int&gt; a;int check(int x) &#123; int last = a[0]; // 先塞第一个牛棚 int count = 1; // 遍历区间 for (auto it = a.begin() + 1; it != a.end(); it++) &#123; // 如果当前的牛棚和上一个牛棚的距离大于或等于最大值 if (*it - last &gt;= x) &#123; last = *it; count++; &#125; // 如果可以把牛全部放进牛棚 if (count &gt;= m) return true; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; a.push_back(x); &#125; sort(a.begin(), a.end(), less&lt;int&gt;()); // [l, r]为闭区间 int l = a[0], r = a[n-1]; // l, r, mid都为距离 while (l &lt;= r) &#123; int mid = (l + r) / 2; // mid为最短距离的最大值 if (check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; r &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"}],"tags":[{"name":"题解","slug":"solution","permalink":"https://blog.luoling8192.top/tags/solution/"},{"name":"二分答案","slug":"binary-answer","permalink":"https://blog.luoling8192.top/tags/binary-answer/"}],"author":[{"name":"RainbowBird"}]},{"title":"【模板】双向BFS","slug":"模板-双向BFS","date":"2020-08-26T10:57:00.000Z","updated":"2020-08-26T11:17:19.130Z","comments":true,"path":"/posts/algorithm/tamplate-twophase-bfs.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm/tamplate-twophase-bfs.html","excerpt":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。","text":"我们都知道BFS搜索的时间复杂度为$O(N^2)$。 而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。 下面请看模板代码。 输入样例： 1234565 5..####....#.#.##.#.##.#.. 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;char a[55][55];int nextn[4][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;int dis[55][55], vst[55][55];struct Node &#123; int x, y;&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(a, 0, sizeof(a)); memset(dis, 0, sizeof(dis)); memset(vst, 0, sizeof(vst)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; queue&lt;Node&gt; que1; // 向前搜 queue&lt;Node&gt; que2; // 向后搜 // vst标记状态 dis表示路程 que1.push(Node&#123;1, 1&#125;), dis[1][1] = 1, vst[1][1] = 1; que2.push(Node&#123;n, m&#125;), dis[n][m] = 1, vst[n][m] = 2; while (!que1.empty() &amp;&amp; !que2.empty()) &#123; int flag; Node head; if (que1.size() &gt; que2.size()) &#123; // 哪个队列元素少就从哪个队列开始搜 head = que2.front(); // 向前搜 que2.pop(); flag = 2; &#125; else &#123; head = que1.front(); // 向后搜 que1.pop(); flag = 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; int tx = head.x + nextn[i][0]; int ty = head.y + nextn[i][1]; if (tx &gt; n || ty &gt; m || tx &lt;= 0 || ty &lt;= 0) continue; if (a[tx][ty] == &#x27;.&#x27;) &#123; if (!dis[tx][ty]) &#123; // 这一步没有队列走过 dis[tx][ty] = dis[head.x][head.y] + 1; // 路程加一 vst[tx][ty] = vst[head.x][head.y]; // 继承状态 if (flag == 1) que1.push(Node&#123;tx, ty&#125;); else if (flag == 2) que2.push(Node&#123;tx, ty&#125;); &#125; else if (vst[head.x][head.y] + vst[tx][ty] == 3) &#123; // 如果相遇 cout &lt;&lt; dis[head.x][head.y] + dis[tx][ty] &lt;&lt; endl; // 步数相加 return 0; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"}],"tags":[{"name":"模板","slug":"template","permalink":"https://blog.luoling8192.top/tags/template/"},{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"}],"author":"RainbowBird"},{"title":"【题解】NOIP2003 乒乓球","slug":"题解-NOIP2003-乒乓球","date":"2020-08-23T09:58:38.000Z","updated":"2020-08-23T10:04:08.401Z","comments":true,"path":"/posts/algorithm/noip2003-table-tennis.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm/noip2003-table-tennis.html","excerpt":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0","text":"这道题我交了好几次，果然还是太菜了（ 说一下注意的点吧： 要特判一下只有E的情况，应该输出0:0 这里的11分制是指其中一个人有11分而不是总共11分 要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出0:0 具体请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* P1217 乒乓球 * 作者: RainbowBird * 日期: 2020-08-18 * 算法: 模拟 */#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, game[25 * 2500 + 5];int main() &#123; // 读入数据 memset(game, 0, sizeof(game)); char ch = getchar(); while (ch != &#x27;E&#x27;) &#123; if (ch == &#x27;W&#x27;) game[++n] = 1; else if (ch == &#x27;L&#x27;) game[++n] = 2; ch = getchar(); &#125; if (n == 0) n = 1; // 11分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 11 || b &gt;= 11) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; printf(&quot;\\n&quot;); // 21分制 &#123; int k = 1; while (k &lt;= n + 1) &#123; // 进行一轮比赛 int a = 0, b = 0, i = 1; while (k &lt;= n + 1) &#123; if ((a &gt;= 21 || b &gt;= 21) &amp;&amp; abs(a-b) &gt;= 2) break; if (game[k] == 1) a++; else if (game[k] == 2) b++; k++, i++; &#125; // 结束这一轮比赛 printf(&quot;%d:%d\\n&quot;, a, b); &#125; &#125; return 0;&#125;","categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"}],"tags":[{"name":"题解","slug":"solution","permalink":"https://blog.luoling8192.top/tags/solution/"}],"author":"RainbowBird"},{"title":"【模板】高精度模板","slug":"模板-高精度模板","date":"2020-08-23T09:57:15.000Z","updated":"2020-08-28T09:28:45.992Z","comments":true,"path":"/posts/algorithm/high-precision-template.html","link":"","permalink":"https://blog.luoling8192.top/posts/algorithm/high-precision-template.html","excerpt":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。","text":"高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。 高精度加法1234567891011121314151617181920212223242526string add(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] + nb[i]; if (nc[i] &gt;= 10) &#123; nc[i+1]++; nc[i] -= 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度减法1234567891011121314151617181920212223242526string sub(string a, string b) &#123; int na[105], nb[105], nc[10005]; memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); int lena = a.length(), lenb = b.length(); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena + lenb; i++) &#123; nc[i] += na[i] - nb[i]; if (nc[i] &lt; 0) &#123; nc[i+1]--; nc[i] += 10; &#125; &#125; int lenc = lena + lenb + 1; while (lenc &gt; 0 &amp;&amp; nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度乘法123456789101112131415161718192021222324252627282930313233string mul(string a, string b) &#123; int na[105], nb[105], nc[10005]; int lena = a.length(), lenb = b.length(); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); for (int i = 1; i &lt;= lena; i++) na[i] = a[lena - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= lena; i++) &#123; for (int j = 1; j &lt;= lenb; j++) &#123; nc[i+j-1] += na[i] * nb[j]; &#125; &#125; for (int i = 1; i &lt; lena + lenb; i++) &#123; if (nc[i] &gt;= 10) &#123; nc[i+1] += nc[i] / 10; nc[i] %= 10; &#125; &#125; int lenc = lena + lenb + 1; while (nc[--lenc] == 0); char c[10005]; for (int i = lenc; i &gt;= 1; i--) c[lenc-i] = nc[i] + &#x27;0&#x27;; return c;&#125; 高精度除法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int cmp(int a[], int b[], int last, int len) &#123; if (a[last+len] != 0) return true; // 如果被除数的位数比除数大 // 逐位比较 for (int i = len; i &gt; 0; i--) &#123; if (a[i+last-1] &gt; b[i]) return true; if (a[i+last-1] &lt; b[i]) return false; &#125; // 相等返回true return true;&#125;void div(string a, string b) &#123; // 声明变量 int lena = a.length(), lenb = b.length(), lenc = lena - lenb + 2, lend = max(lena, lenb) + 1; // 清空变量 memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); memset(nc, 0, sizeof(nc)); // 商 memset(nd, 0, sizeof(nd)); // 余数 // 把数字倒过来存 for (int i = 1; i &lt;= lena; i++) na[i] = a[lena-i] - &#x27;0&#x27;, nd[i] = na[i]; for (int i = 1; i &lt;= lenb; i++) nb[i] = b[lenb-i] - &#x27;0&#x27;; //for (int i = 1; i &lt;= lena; i++) nd[i] = na[i]; // 存余数 // 高精度除法 for (int i = lena - lenb + 1; i &gt; 0; i--) &#123; // 被除数和除数对齐 /* 456 / 12 * 38 * 12 |---- * 456 * 36 * ---- * 96 * 96 * ---- * 0 */ // 可以相减 while (cmp(nd, nb, i, lenb)) &#123; // 高精度减法 for (int j = 1; j &lt;= lenb; j++) &#123; nd[i+j-1] -= nb[j]; if (nd[i+j-1] &lt; 0) &#123; nd[i+j]--; nd[i+j-1] += 10; &#125; &#125; nc[i]++; // 商进一位 &#125; &#125; // 输出商 while (nc[--lenc] == 0); if (lenc &lt;= 0) lenc++; for (int i = lenc; i &gt; 0; i--) &#123; cout &lt;&lt; nc[i]; &#125; cout &lt;&lt; endl; // 输出余数 while (nd[--lend] == 0); if (lend &lt;= 0) lend++; for (int i = lend; i &gt; 0; i--) &#123; cout &lt;&lt; nd[i]; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"}],"tags":[{"name":"模板","slug":"template","permalink":"https://blog.luoling8192.top/tags/template/"},{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}],"author":[{"name":"RainbowBird"}]},{"title":"欢迎","slug":"欢迎","date":"2020-08-23T04:13:58.000Z","updated":"2020-08-28T04:35:59.403Z","comments":true,"path":"/posts/daily/welcome.html","link":"","permalink":"https://blog.luoling8192.top/posts/daily/welcome.html","excerpt":"欢迎来到我的博客！ 关于我 2020年8月22日之前的博客在博客园可以找到。","text":"欢迎来到我的博客！ 关于我 2020年8月22日之前的博客在博客园可以找到。","categories":[{"name":"日常","slug":"daily","permalink":"https://blog.luoling8192.top/categories/daily/"}],"tags":[],"author":"RainbowBird"}],"categories":[{"name":"算法竞赛","slug":"algorithm","permalink":"https://blog.luoling8192.top/categories/algorithm/"},{"name":"日常","slug":"daily","permalink":"https://blog.luoling8192.top/categories/daily/"}],"tags":[{"name":"题解","slug":"solution","permalink":"https://blog.luoling8192.top/tags/solution/"},{"name":"进制转换","slug":"sys-convert","permalink":"https://blog.luoling8192.top/tags/sys-convert/"},{"name":"二分答案","slug":"binary-answer","permalink":"https://blog.luoling8192.top/tags/binary-answer/"},{"name":"模板","slug":"template","permalink":"https://blog.luoling8192.top/tags/template/"},{"name":"搜索","slug":"search","permalink":"https://blog.luoling8192.top/tags/search/"},{"name":"高精度","slug":"high-precision","permalink":"https://blog.luoling8192.top/tags/high-precision/"}]}