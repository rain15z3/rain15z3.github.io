<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【模板】字典树</title>
      <link href="//posts/algorithm-template/trie-tree.html"/>
      <url>//posts/algorithm-template/trie-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h2><blockquote><p>原理在<a href="https://blog.csdn.net/weixin_39778570/article/details/81990417">这篇</a>文章中讲的很清楚了，非常感谢。</p></blockquote><a id="more"></a><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/2.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="字典树的样子"></p><h2 id="为什么要用字典树"><a href="#为什么要用字典树" class="headerlink" title="为什么要用字典树"></a>为什么要用字典树</h2><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[<span class="number">10005</span>][<span class="number">26</span>]; <span class="comment">// 最大深度 最大字符集</span></span><br><span class="line"><span class="keyword">int</span> book[<span class="number">10005</span>];     <span class="comment">// 用于标识是否为终结点</span></span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;         <span class="comment">// 从1开始因为0是根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;                  <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 把小写字母转换为数字（从0-25，分别对应a-z）</span></span><br><span class="line">        <span class="keyword">if</span> (!trie[p][c])        <span class="comment">// 如果当前节点没有一条为c的边</span></span><br><span class="line">            trie[p][c] = cur++; <span class="comment">// 添加一条边，边总数加1</span></span><br><span class="line">        p = trie[p][c];         <span class="comment">// 指针移到当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    book[p] = <span class="number">1</span>;                <span class="comment">// 遍历完成，在最后一条边上打上结束标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][c]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果当前字母的边没有找到则返回false</span></span><br><span class="line">        p = trie[p][c];                <span class="comment">// 指针指向当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> book[p] == <span class="number">1</span>;               <span class="comment">// 如果当前边有结束标记则说明找到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单写完<code>main</code>函数就完成了一个字典树的demo。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        insert(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (search(a)) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/1.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2005 校门外的树（离散化实现）</title>
      <link href="//posts/algorithm-solution/noip2005-school-tree.html"/>
      <url>//posts/algorithm-solution/noip2005-school-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1047">P1047 校门外的树</a></p><p>今天用这道题目来练习一下离散化。</p><p>当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。</p><a id="more"></a><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">// 位置</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">// 前缀和</span></span><br><span class="line">&#125; a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离散化存储</span></span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>].pos = x;   <span class="comment">// 左端点的位置</span></span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>].num = <span class="number">1</span>;   <span class="comment">// 左端点用1表示</span></span><br><span class="line">        a[i*<span class="number">2</span>].pos = y + <span class="number">1</span>; <span class="comment">// 右端点的位置（差分用，所以这里是y+1）</span></span><br><span class="line">        a[i*<span class="number">2</span>].num = <span class="number">-1</span>;    <span class="comment">// 右端点用-1表示</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span>, a + m * <span class="number">2</span> + <span class="number">1</span>, cmp); <span class="comment">// 按照左端点的位置升序排列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * <span class="number">2</span>; i++) &#123; <span class="comment">// 一共有2m个点，全部遍历一遍</span></span><br><span class="line">        sum += a[i].num; <span class="comment">// sum用来存储当前状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当sum的值由0变为1时说明中间经过了一段没有树的区间</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span> &amp;&amp; a[i].num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 这时a[i]是左端点，a[i-1]是上个区间的右端点</span></span><br><span class="line">            total += a[i].pos - a[i<span class="number">-1</span>].pos; <span class="comment">// 加上区间长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个右端点到区间终点的距离</span></span><br><span class="line">    total += l - a[m*<span class="number">2</span>].pos + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】快速幂</title>
      <link href="//posts/algorithm-template/template-quick-pow.html"/>
      <url>//posts/algorithm-template/template-quick-pow.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天学了倍增，终于把非递归快速幂看懂了。</p><a id="more"></a><p>还是把$a^n$拆分成二进制形式。</p><p>例如：<br>$$<br>a^{10} = a^{(1010) _ 2} = a^{1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0} = a^{1 * 2^3} * a^{1 * 2^1}<br>$$</p><p>我们可以通过倍增的方法先计算$\mod p$意义下的$a^1$，$a^2$，$a^4$，$a^8$，$a^{16}$，$a^{32}$，再把它们根据$b$的二进制拆分乘起来。</p><p>下面请看代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a ^ b % p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a; <span class="comment">// 倍增（a^1 a^2 a^3 ...）</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) <span class="comment">// 二进制最后一位是1</span></span><br><span class="line">            ans = (ans * t) % p;</span><br><span class="line">        t = (t * t) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; <span class="comment">// 计算下一个二进制的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="//posts/algorithm-note/algorithmic-learning-notes.html"/>
      <url>//posts/algorithm-note/algorithmic-learning-notes.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>蒟蒻的学习笔记，时不时拿出来看一看。</p><a id="more"></a><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="gcd-最大公约数"><a href="#gcd-最大公约数" class="headerlink" title="gcd 最大公约数"></a>gcd 最大公约数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mod = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lcm-最小公倍数"><a href="#lcm-最小公倍数" class="headerlink" title="lcm 最小公倍数"></a>lcm 最小公倍数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h3><p>互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。</p><h3 id="基本不等式"><a href="#基本不等式" class="headerlink" title="基本不等式"></a>基本不等式</h3><p>$$a+b \geq 2 \sqrt{ab}$$</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>$f(1) = 1$</p><p>$f(2) = 1$</p><p>$f(3) = f(1) + f(2) = f(3-2) + f(3-1)$</p><p>$f(n) = f(n-2) + f(n-1)$</p><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$f(0) = 1$</p><p>$f(1) = 1$</p><p>$f(n) = f(0) * f(n-1) + f(1) * f(n-2) \cdots + f(n) * f(0)$</p><p>应用：长度为n的栈一共有多少种出栈的方法。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>前序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/2.jpg" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="初赛知识点"><a href="#初赛知识点" class="headerlink" title="初赛知识点"></a>初赛知识点</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>相同为0，不同为1。</p><p>$n^{\wedge}0$不变，$n^{\wedge}1$取反。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>源码的绝对值取反加1。</p><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算数运算符</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/3.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>$$<br>A^m_n=n * (n-1) * (n-2) * \cdots * (n-m+1) = \frac{n!}{(n-m)!}<br>$$</p><h4 id="全组合"><a href="#全组合" class="headerlink" title="全组合"></a>全组合</h4><p>$$<br>C^m_n= \frac{A^m_n}{A^m_m} = \frac{n * (n-1) * (n-2) * \cdots * (n-m+1)}{1 * 2 * 3 * 4 * \cdots * m} = \frac{n!}{m!(n-m)!}<br>$$</p><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>$A[1 \ldots n]$如有$i \lt j$且$A[i] \gt A[j]$则称为逆序对。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>$$(a * b) \mod p=(a \mod p*b \mod p) \mod p$$</p><p>$$(a + b) \mod p = (a \mod p + b \mod p) \mod p$$</p><p>$$(a - b) \mod p = (a \mod p - b \mod p) \mod p$$</p><p>$$(a ^ b \mod p) = ((a \mod p) ^ b) \mod p$$</p><p>$$((a+b) \mod p + c) \mod p = (a + (b+c) \mod p) \mod p$$</p><p>$$((a+b) \mod p * c) \mod p = ((a * c) \mod p + (b * c) \mod p) \mod p$$</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><code>mid = (l + r) / 2;</code>等价于<code>mid = l + (r - l) / 2</code>。</p><p>第一种写法可能会爆<code>int</code>。</p><p><strong>求最小值最大（最大值最小）一般使用二分答案来进行求解。</strong></p><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erfen</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 注意二分条件</span></span><br><span class="line">        mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">erfen</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123; <span class="comment">// dlt = 0.001(精度)</span></span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(l-r) &gt; dlt) &#123;</span><br><span class="line">        mid = (l+r) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Min-heap: 父节点的值小于或等于子节点的值。</p><p>Max-heap: 父节点的值大于或等于子节点的值。</p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/1.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li><p><code>upper_bound</code><br>找到第一个大于<code>x</code>的数。</p></li><li><p><code>lower_bound</code><br>找到第一个大于等于<code>x</code>的数。</p></li><li><p><code>greater&lt;int&gt;()</code><br>降序排列。</p></li><li><p><code>less&lt;int&gt;()</code><br>升序排列。</p></li><li><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;</code><br>优先队列（大根堆）。</p></li><li><p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap;</code><br>优先队列（小根堆）。</p></li><li><p><code>next_permutation(a, a+n)</code><br>生成a的全排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(a, a + n);</span><br></pre></td></tr></table></figure></li></ul><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li><p><code>scanf(&quot; %c&quot;, &amp;n)</code><br>其中<code>%c</code>前面加一个空格可以过滤掉一切的<strong>空格</strong>，<strong>回车</strong>以及<strong>Tab</strong>，如果没有的话则不影响。</p></li><li><p>函数有返回值而不返回或者数组下标越界可能会产生各种奇怪的问题，比如C++11能AC但是C++14会RE等等。</p></li><li><p>用<code>memset</code>给<code>int</code>赋值为<code>0x7f</code>即为近似最大值，二进制位为<code>0111 0111 0111 0111</code>。</p></li><li><p>有向无环图的单源点最短路使用BFS算法最佳。</p></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="搜索究竟解决的是一个什么问题？"><a href="#搜索究竟解决的是一个什么问题？" class="headerlink" title="搜索究竟解决的是一个什么问题？"></a>搜索究竟解决的是一个什么问题？</h3><blockquote><p>在某一个空间里寻找目标。</p><p>空间指的是<strong>解空间</strong>。</p><p>目标指的是<strong>目标状态</strong>。</p></blockquote><ul><li>解空间：如果把一个问题的解抽象成一个数学上的向量，那么包含这个向量的空间，就是解空间。</li><li>目标状态：用于描述问题或者问题的解的一些量（我是谁？我在哪？）。</li></ul><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/4.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解空间和目标状态"></p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/5.png" class="lazyload" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="目标状态举例"></p><p>(有助于理解动态规划?)</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 初赛 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】USACO 愤怒的牛</title>
      <link href="//posts/algorithm-solution/usaco-the-angry-bull.html"/>
      <url>//posts/algorithm-solution/usaco-the-angry-bull.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://loj.ac/problem/10011">「一本通 1.2 例 1」愤怒的牛</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用<code>check()</code>函数来判断答案的可行性。</p><div class="note info">            <p><span class='p yellow'>求最小值最大</span>或<span class='p yellow'>求最大值最小</span>是典型的二分答案。</p>          </div><p>要注意的是二分的边界。</p><blockquote><p>推荐阅读：<a href="https://blog.csdn.net/qq1515312832/article/details/105846202">二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？</a></p></blockquote><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P10011 愤怒的牛</span></span><br><span class="line"><span class="comment"> * 来源: 信息学奥赛一本通 提高篇</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-29</span></span><br><span class="line"><span class="comment"> * 算法: 二分答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = a[<span class="number">0</span>]; <span class="comment">// 先塞第一个牛棚</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.begin() + <span class="number">1</span>; it != a.end(); it++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的牛棚和上一个牛棚的距离大于或等于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (*it - last &gt;= x) &#123;</span><br><span class="line">            last = *it;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以把牛全部放进牛棚</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        a.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(), a.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [l, r]为闭区间</span></span><br><span class="line">    <span class="keyword">int</span> l = a[<span class="number">0</span>], r = a[n<span class="number">-1</span>]; <span class="comment">// l, r, mid都为距离</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// mid为最短距离的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2000 进制转换</title>
      <link href="//posts/algorithm-solution/noip2000-sys-convert.html"/>
      <url>//posts/algorithm-solution/noip2000-sys-convert.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1017">P1017 进制转换</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题考察的是负进制转换。</p><p>我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。</p><a id="more"></a><p>十进制转二进制的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary[<span class="number">255</span>], cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    binary[++cur] = n % m;</span><br><span class="line">    n /= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中n为十进制下的数字，m为需要转换的进制。</p></blockquote><p>那么当目标进制为负数的时候要注意什么呢？</p><p><strong>余数不能为负数</strong>。</p><p>例如，$(19)_{10}$要转换成$-9$进制。</p><p>$19/-9=-2…1$</p><p>$-2/-9=1…7$（注意这里不是<emp>$0...-2$</emp>！因为负数不能做余数。）</p><p>$1/-9=0…1$（当商为0时计算完成）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P1017 进制转换</span></span><br><span class="line"><span class="comment"> * 来源: NOIP2000</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-28</span></span><br><span class="line"><span class="comment"> * 算法: 负进制转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> nums[<span class="number">20</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">10005</span>], cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; <span class="comment">// 注意这里是不等于，因为商可能为负数</span></span><br><span class="line">        <span class="keyword">int</span> mod = n % r; <span class="comment">// 获取余数</span></span><br><span class="line">        n /= r;          <span class="comment">// 获取商</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果余数小于0，那么商进一位，余数则等于进制数的绝对值减去余数的绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (mod &lt; <span class="number">0</span>) n++, mod = <span class="built_in">abs</span>(r) - <span class="built_in">abs</span>(mod);</span><br><span class="line">        ans[cur++] = nums[mod];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由高位到低位倒序输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ans[i]); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(base%d)\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】双向BFS</title>
      <link href="//posts/algorithm-template/tamplate-twophase-bfs.html"/>
      <url>//posts/algorithm-template/tamplate-twophase-bfs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们都知道BFS搜索的时间复杂度为$O(N^2)$。</p><p>而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。</p><p>下面请看模板代码。</p><a id="more"></a><p>输入样例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">..###</span><br><span class="line">#....</span><br><span class="line">#.#.#</span><br><span class="line">#.#.#</span><br><span class="line">#.#..</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> nextn[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">55</span>][<span class="number">55</span>], vst[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; que1; <span class="comment">// 向前搜 </span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; que2; <span class="comment">// 向后搜 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vst标记状态 dis表示路程 </span></span><br><span class="line">    que1.push(Node&#123;<span class="number">1</span>, <span class="number">1</span>&#125;), dis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>, vst[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    que2.push(Node&#123;n, m&#125;), dis[n][m] = <span class="number">1</span>, vst[n][m] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que1.empty() &amp;&amp; !que2.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag; </span><br><span class="line">        Node head;</span><br><span class="line">        <span class="keyword">if</span> (que1.size() &gt; que2.size()) &#123; <span class="comment">// 哪个队列元素少就从哪个队列开始搜 </span></span><br><span class="line">            head = que2.front(); <span class="comment">// 向前搜</span></span><br><span class="line">            que2.pop();</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = que1.front(); <span class="comment">// 向后搜</span></span><br><span class="line">            que1.pop();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tx = head.x + nextn[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ty = head.y + nextn[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tx &gt; n || ty &gt; m || tx &lt;= <span class="number">0</span> || ty &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dis[tx][ty]) &#123; <span class="comment">// 这一步没有队列走过</span></span><br><span class="line">                    dis[tx][ty] = dis[head.x][head.y] + <span class="number">1</span>; <span class="comment">// 路程加一 </span></span><br><span class="line">                    vst[tx][ty] = vst[head.x][head.y]; <span class="comment">// 继承状态 </span></span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">1</span>) que1.push(Node&#123;tx, ty&#125;); </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) que2.push(Node&#123;tx, ty&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vst[head.x][head.y] + vst[tx][ty] == <span class="number">3</span>) &#123; <span class="comment">// 如果相遇 </span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; dis[head.x][head.y] + dis[tx][ty] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 步数相加 </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2003 乒乓球</title>
      <link href="//posts/algorithm-solution/noip2003-table-tennis.html"/>
      <url>//posts/algorithm-solution/noip2003-table-tennis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这道题我交了好几次，果然还是太菜了（</p><p>说一下注意的点吧：</p><ul><li>要特判一下只有<code>E</code>的情况，应该输出<code>0:0</code></li><li>这里的11分制是指其中一个人有11分而不是总共11分</li><li>要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出<code>0:0</code></li></ul><a id="more"></a><p>具体请看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P1217 乒乓球</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-18</span></span><br><span class="line"><span class="comment"> * 算法: 模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, game[<span class="number">25</span> * <span class="number">2500</span> + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="built_in">memset</span>(game, <span class="number">0</span>, <span class="keyword">sizeof</span>(game));</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;W&#x27;</span>) game[++n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;L&#x27;</span>) game[++n] = <span class="number">2</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11分制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行一轮比赛</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &gt;= <span class="number">11</span> || b &gt;= <span class="number">11</span>) &amp;&amp; <span class="built_in">abs</span>(a-b) &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (game[k] == <span class="number">1</span>) a++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (game[k] == <span class="number">2</span>) b++;</span><br><span class="line"></span><br><span class="line">                k++, i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束这一轮比赛</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 21分制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行一轮比赛</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &gt;= <span class="number">21</span> || b &gt;= <span class="number">21</span>) &amp;&amp; <span class="built_in">abs</span>(a-b) &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (game[k] == <span class="number">1</span>) a++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (game[k] == <span class="number">2</span>) b++;</span><br><span class="line"></span><br><span class="line">                k++, i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束这一轮比赛</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】高精度模板</title>
      <link href="//posts/algorithm-template/high-precision-template.html"/>
      <url>//posts/algorithm-template/high-precision-template.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。</p><a id="more"></a><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena + lenb; i++) &#123;</span><br><span class="line">        nc[i] += na[i] + nb[i];</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>]++;</span><br><span class="line">            nc[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lenc &gt; <span class="number">0</span> &amp;&amp; nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sub</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena + lenb; i++) &#123;</span><br><span class="line">        nc[i] += na[i] - nb[i];</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>]--;</span><br><span class="line">            nc[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lenc &gt; <span class="number">0</span> &amp;&amp; nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">mul</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++)</span><br><span class="line">        na[i] = a[lena - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++)</span><br><span class="line">        nb[i] = b[lenb - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">            nc[i+j<span class="number">-1</span>] += na[i] * nb[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lena + lenb; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>] += nc[i] / <span class="number">10</span>;</span><br><span class="line">            nc[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[last+len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果被除数的位数比除数大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i+last<span class="number">-1</span>] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i+last<span class="number">-1</span>] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相等返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length(), lenc = lena - lenb + <span class="number">2</span>, lend = max(lena, lenb) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空变量</span></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc)); <span class="comment">// 商</span></span><br><span class="line">    <span class="built_in">memset</span>(nd, <span class="number">0</span>, <span class="keyword">sizeof</span>(nd)); <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把数字倒过来存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>, nd[i] = na[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= lena; i++) nd[i] = na[i]; // 存余数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高精度除法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lena - lenb + <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 被除数和除数对齐</span></span><br><span class="line">        <span class="comment">/* 456 / 12</span></span><br><span class="line"><span class="comment">         *      38</span></span><br><span class="line"><span class="comment">         * 12 |----</span></span><br><span class="line"><span class="comment">         *     456</span></span><br><span class="line"><span class="comment">         *     36</span></span><br><span class="line"><span class="comment">         *     ----</span></span><br><span class="line"><span class="comment">         *      96</span></span><br><span class="line"><span class="comment">         *      96</span></span><br><span class="line"><span class="comment">         *     ----</span></span><br><span class="line"><span class="comment">         *       0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以相减</span></span><br><span class="line">        <span class="keyword">while</span> (cmp(nd, nb, i, lenb)) &#123;</span><br><span class="line">            <span class="comment">// 高精度减法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">                nd[i+j<span class="number">-1</span>] -= nb[j];</span><br><span class="line">                <span class="keyword">if</span> (nd[i+j<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nd[i+j]--;</span><br><span class="line">                    nd[i+j<span class="number">-1</span>] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nc[i]++; <span class="comment">// 商进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出商</span></span><br><span class="line">    <span class="keyword">while</span> (nc[--lenc] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lenc &lt;= <span class="number">0</span>) lenc++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nc[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出余数</span></span><br><span class="line">    <span class="keyword">while</span> (nd[--lend] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lend &lt;= <span class="number">0</span>) lend++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lend; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nd[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎</title>
      <link href="//posts/daily/welcome.html"/>
      <url>//posts/daily/welcome.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>欢迎来到我的博客！</p><p><a href="http://blog.luoling8192.top:82/about/">关于我</a></p><p>2020年8月22日之前的博客在<a href="https://www.cnblogs.com/luoling8192/">博客园</a>可以找到。</p>    <div id="aplayer-AQpRiSPN" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29418656" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
