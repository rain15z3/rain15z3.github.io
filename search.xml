<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【模板】Dijkstra算法</title>
      <link href="//posts/algorithm-template/dijkstra.html"/>
      <url>//posts/algorithm-template/dijkstra.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>Dijkstra算法是一种求最短路的算法，在使用优先队列进行优化后时间复杂度比较优秀。</p><a id="more"></a><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>如果图是不带负权的有向图或者无向图，我们可以从<code>s</code>点开始寻找它的所有出边，与数组<code>dis</code>（每个点离原点<code>s</code>点的最短距离）进行比较，如果有小于<code>dis[v]</code>的路径，则松弛该点，最后可以得到一个所有最短路径的表。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>初始化<code>dis</code>数组，原点赋值为<code>0</code>，其它点全部赋值为<code>INF</code>（为原点到该点的距离）。</li><li>重复<code>n</code>次操作，找到<code>x</code>的所有出边，对需要进行松弛的边进行松弛。</li></ol><p>该算法的时间复杂度为$O(n^2)$，使用优先队列优化后的算法时间复杂度为$O((n+m)\log m)$。</p><p>文中代码边的存储使用链式前向星实现。</p><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5</span> * <span class="number">10e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], book[MAXN], head[MAXN], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">&#125; e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加一条边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">    fill(dis, dis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="comment">// 有向带权图</span></span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dijkstra</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.top().second;</span><br><span class="line">        que.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请勿重复查找</span></span><br><span class="line">        <span class="keyword">if</span> (book[x]) <span class="keyword">continue</span>;</span><br><span class="line">        book[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描所有出边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[x] + e[i].w) &#123;</span><br><span class="line">                dis[v] = dis[x] + e[i].w; <span class="comment">// 松弛</span></span><br><span class="line">                que.push(&#123;-dis[v], v&#125;); <span class="comment">// 用pair实现可以把dis值赋值成负数就可以实现小根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】CF1419A Digit Game</title>
      <link href="//posts/algorithm-soultion/cf1419a-digit-game.html"/>
      <url>//posts/algorithm-soultion/cf1419a-digit-game.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>蒟蒻第一次打codeforces结果爆零….</p><p>今天早上看一下测试点发现原来是int存不下，我昨天怎么没发现呢！！！</p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>大概就是有两个人在玩选数游戏，<code>Raze</code>先开始选择，他只能选择奇数位上的数，而<code>Breach</code>只能选择偶数位上的数。</p><p><strong>最后要保留一位数进行奇偶校验！</strong></p><p>如果最后一位是偶数，那么<code>Breach</code>赢，输出<code>2</code>；如果最后一位是奇数，那么<code>Raze</code>赢，输出<code>1</code>。</p><p>他们非常聪明，都会让自己尽可能的赢。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我们可以看出，如果要让自己赢，则：</p><ul><li><code>Raze</code>每次选择数字是要尽可能的选择偶数，使得数字中的偶数尽可能少。</li><li><code>Breach</code>每次选择数字是要尽可能的选择奇数，使得数字中的奇数尽可能少。</li></ul><p>如果数字只有一位就可以直接判断输出了qwq</p><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> book[<span class="number">5005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = n / <span class="number">2</span>; k &gt; <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">int</span> flaga = <span class="number">0</span>, flagb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123; <span class="comment">// 奇数位</span></span><br><span class="line">                <span class="keyword">if</span> ((a[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 尽量去掉偶数</span></span><br><span class="line">                    <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        book[i] = <span class="number">1</span>; <span class="comment">// 去掉</span></span><br><span class="line">                        flaga = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flaga) &#123;</span><br><span class="line">                <span class="comment">// 如果没有则随便去掉一个</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123; <span class="comment">// 奇数位</span></span><br><span class="line">                    <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        book[i] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 如果是偶数位则留下一位判断</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123; <span class="comment">// 偶数位</span></span><br><span class="line">                <span class="keyword">if</span> ((a[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 尽量去掉奇数</span></span><br><span class="line">                    <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        book[i] = <span class="number">1</span>; <span class="comment">// 去掉</span></span><br><span class="line">                        flagb = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flagb) &#123;</span><br><span class="line">                <span class="comment">// 如果没有则随便去掉一个</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123; <span class="comment">// 偶数位</span></span><br><span class="line">                    <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        book[i] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法学习】背包问题</title>
      <link href="//posts/algorithm-note/knapsack.html"/>
      <url>//posts/algorithm-note/knapsack.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天好像终于搞懂了01背包问题。</p><p>先放上代码，过程以后再补。</p><a id="more"></a><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T, m;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>], v[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m][T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T, m;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>], v[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">                f[j] = max(f[j], f[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包相当于01背包只需要改动一句即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= <span class="number">0</span>; j--)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= T; j++)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
            <tag> 01背包 </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】线段树</title>
      <link href="//posts/algorithm-template/segment-tree.html"/>
      <url>//posts/algorithm-template/segment-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><div class="note quote"><p>以下内容摘自<a href="https://oi-wiki.org/ds/seg/">OI-Wiki</a></p></div><p>线段树是算法竞赛中常用的用来维护<strong>区间信息</strong>的数据结构。</p><a id="more"></a><p>线段树可以在$O(\log N)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><p>线段树维护的信息，需要满足可加性，即能以可以接受的速度合并信息和修改信息，包括在使用懒惰标记时，标记也要满足可加性（例如取模就不满足可加性，对$4$取模然后对$3$取模，两个操作就不能合并在一起做）。</p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/segment-tree/1.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/segment-tree/1.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="线段树"></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">100005</span>];</span><br><span class="line">ll tree[<span class="number">100005</span>]; <span class="comment">// 左子树下标p*2，右子树下标p*2+1</span></span><br><span class="line">ll lazy[<span class="number">100005</span>]; <span class="comment">// 懒惰标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> st &#123;</span><br><span class="line"><span class="comment">// p: 当前数组的下标</span></span><br><span class="line"><span class="comment">// l, r: 区间l-r，在数组a里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    lazy[p] = <span class="number">0</span>; <span class="comment">// 懒惰标签清空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;       <span class="comment">// 如果已经到了最小的部分</span></span><br><span class="line">        tree[p] = a[l]; <span class="comment">// 把当前数组a的值赋值给线段树tree[p]</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(p * <span class="number">2</span>, l, mid);                    <span class="comment">// 建立左子树</span></span><br><span class="line">    build(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);            <span class="comment">// 建立右子树</span></span><br><span class="line">    tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 当前数的值等于子树的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len: 下传的子树区间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子树节点的懒惰标记加上父亲节点的懒惰标记</span></span><br><span class="line">    lazy[p * <span class="number">2</span>] += lazy[p];</span><br><span class="line">    lazy[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子树更新区间和</span></span><br><span class="line">    tree[p * <span class="number">2</span>] += (len - len / <span class="number">2</span>) * lazy[p];</span><br><span class="line">    tree[p * <span class="number">2</span> + <span class="number">1</span>] += (len / <span class="number">2</span>) * lazy[p];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除父亲节点的懒惰标记</span></span><br><span class="line">    lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y: 修改[x,y]这个区间</span></span><br><span class="line"><span class="comment">// num: 修改的值，加上一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;           <span class="comment">// [l,r]区间包含了当前区间[x,y]</span></span><br><span class="line">        lazy[p] += num;               <span class="comment">// 修改区间[l,r]的懒惰标签</span></span><br><span class="line">        tree[p] += (num * ll(r - l + <span class="number">1</span>)); <span class="comment">// 当前区间的区间和加上左右子树的和</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下搜索</span></span><br><span class="line">    pushdown(p, (r - l + <span class="number">1</span>)); <span class="comment">// 懒惰标记下传（只下穿一层）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        change(p * <span class="number">2</span>, l, mid, x, y, num); <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">        change(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, num); <span class="comment">// 遍历右子树</span></span><br><span class="line"></span><br><span class="line">    tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新区间和（左子树和右子树的和）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y: 需要查询的区间左右界</span></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) <span class="comment">// 如果区间[l,r]被完整包含在了需要查询的区间[x,y]里面</span></span><br><span class="line">        <span class="keyword">return</span> tree[p]; <span class="comment">// 返回区间[l,r]的区间和</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lazy[p] != <span class="number">0</span>) <span class="comment">// 如果节点含有懒惰标记</span></span><br><span class="line">        pushdown(p, r - l + <span class="number">1</span>); <span class="comment">// 懒惰标记下传</span></span><br><span class="line"></span><br><span class="line">    ll re = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="comment">// 如果需要查询的区间在mid的左边</span></span><br><span class="line">        re += find(p * <span class="number">2</span>, l, mid, x, y); <span class="comment">// 搜索左子树</span></span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid) <span class="comment">// 如果需要查询的区间在mid的右边</span></span><br><span class="line">        re += find(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y); <span class="comment">// 搜索右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace st</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st::build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">// 建立线段树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">            st::change(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            ll ans = st::find(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】字典树</title>
      <link href="//posts/algorithm-template/trie-tree.html"/>
      <url>//posts/algorithm-template/trie-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h2><blockquote><p>原理在<a href="https://blog.csdn.net/weixin_39778570/article/details/81990417">这篇</a>文章中讲的很清楚了，非常感谢。</p></blockquote><a id="more"></a><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/2.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/2.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="字典树的样子"></p><h2 id="为什么要用字典树"><a href="#为什么要用字典树" class="headerlink" title="为什么要用字典树"></a>为什么要用字典树</h2><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[<span class="number">10005</span>][<span class="number">26</span>]; <span class="comment">// 最大深度 最大字符集</span></span><br><span class="line"><span class="keyword">int</span> book[<span class="number">10005</span>];     <span class="comment">// 用于标识是否为终结点</span></span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;         <span class="comment">// 从1开始因为0是根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;                  <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 把小写字母转换为数字（从0-25，分别对应a-z）</span></span><br><span class="line">        <span class="keyword">if</span> (!trie[p][c])        <span class="comment">// 如果当前节点没有一条为c的边</span></span><br><span class="line">            trie[p][c] = cur++; <span class="comment">// 添加一条边，边总数加1</span></span><br><span class="line">        p = trie[p][c];         <span class="comment">// 指针移到当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    book[p] = <span class="number">1</span>;                <span class="comment">// 遍历完成，在最后一条边上打上结束标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][c]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果当前字母的边没有找到则返回false</span></span><br><span class="line">        p = trie[p][c];                <span class="comment">// 指针指向当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> book[p] == <span class="number">1</span>;               <span class="comment">// 如果当前边有结束标记则说明找到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单写完<code>main</code>函数就完成了一个字典树的demo。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        insert(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (search(a)) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/1.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/trie-tree/1.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg"></p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2005 校门外的树（离散化实现）</title>
      <link href="//posts/algorithm-soultion/noip2005-school-tree.html"/>
      <url>//posts/algorithm-soultion/noip2005-school-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1047">P1047 校门外的树</a></p><p>今天用这道题目来练习一下离散化。</p><p>当然这道题并不需要离散化，但是当数据范围开到数组开不下时离散化还是很有必要的。</p><a id="more"></a><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">// 位置</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">// 前缀和</span></span><br><span class="line">&#125; a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离散化存储</span></span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>].pos = x;   <span class="comment">// 左端点的位置</span></span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>].num = <span class="number">1</span>;   <span class="comment">// 左端点用1表示</span></span><br><span class="line">        a[i*<span class="number">2</span>].pos = y + <span class="number">1</span>; <span class="comment">// 右端点的位置（差分用，所以这里是y+1）</span></span><br><span class="line">        a[i*<span class="number">2</span>].num = <span class="number">-1</span>;    <span class="comment">// 右端点用-1表示</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span>, a + m * <span class="number">2</span> + <span class="number">1</span>, cmp); <span class="comment">// 按照左端点的位置升序排列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * <span class="number">2</span>; i++) &#123; <span class="comment">// 一共有2m个点，全部遍历一遍</span></span><br><span class="line">        sum += a[i].num; <span class="comment">// sum用来存储当前状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当sum的值由0变为1时说明中间经过了一段没有树的区间</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span> &amp;&amp; a[i].num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 这时a[i]是左端点，a[i-1]是上个区间的右端点</span></span><br><span class="line">            total += a[i].pos - a[i<span class="number">-1</span>].pos; <span class="comment">// 加上区间长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个右端点到区间终点的距离</span></span><br><span class="line">    total += l - a[m*<span class="number">2</span>].pos + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】快速幂</title>
      <link href="//posts/algorithm-template/template-quick-pow.html"/>
      <url>//posts/algorithm-template/template-quick-pow.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天学了倍增，终于把非递归快速幂看懂了。</p><a id="more"></a><p>还是把$a^n$拆分成二进制形式。</p><p>例如：<br>$$<br>a^{10} = a^{(1010) _ 2} = a^{1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0} = a^{1 * 2^3} * a^{1 * 2^1}<br>$$</p><p>我们可以通过倍增的方法先计算$\mod p$意义下的$a^1$，$a^2$，$a^4$，$a^8$，$a^{16}$，$a^{32}$，再把它们根据$b$的二进制拆分乘起来。</p><p>下面请看代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a ^ b % p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a; <span class="comment">// 倍增（a^1 a^2 a^3 ...）</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) <span class="comment">// 二进制最后一位是1</span></span><br><span class="line">            ans = (ans * t) % p;</span><br><span class="line">        t = (t * t) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; <span class="comment">// 计算下一个二进制的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="//posts/algorithm-note/algorithmic-learning-notes.html"/>
      <url>//posts/algorithm-note/algorithmic-learning-notes.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>蒟蒻的学习笔记，时不时拿出来看一看。</p><a id="more"></a><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p><code>gcd(a, b) = gcd(b, a % b)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mod = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h3><p>互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。</p><h3 id="基本不等式"><a href="#基本不等式" class="headerlink" title="基本不等式"></a>基本不等式</h3><p>$$a+b \geq 2 \sqrt{ab}$$</p><h3 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h3><p>任何一个大于1的正整数都能唯一分解成有限个质数的乘积，可以写作：<br>$$N = p_1^{c_1}p_2^{c_2}p_3^{c_3} \cdots p_m^{c_m}$$<br>其中$p_1,p_2,p_3 \cdots p_i$都是质数且递增，$c_i$都是正整数。</p><h4 id="基本算数定理的推论"><a href="#基本算数定理的推论" class="headerlink" title="基本算数定理的推论"></a>基本算数定理的推论</h4><ul><li><p>$N$的正整数合集为$p_1^{b_1}p_2^{b_2}p_3^{b_3} \cdots p_m^{b_m}$，其中$0 \leq b_i \leq c_i$。</p></li><li><p>$N$的正约数个数为$\prod^m_{i=1}(c_i+1)$。</p></li><li><p>$N$的所有正约数的和为$(1+p_1+{p_1}^2+ \cdots +{p_1}^{c_1}) \times \cdots \times ((1+p_m+{p_m}^2+ \cdots +{p_m}^{c_1}) = \prod^m_{m=1}(\sum^{c_i}_{j=0}(p_m)^j)$。</p></li></ul><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>两个数的<code>gcd</code>等于$1$，即两个数互质。</p><p>$1$到$n$中与$n$互质的数的个数成为欧拉函数记$\phi(n)$。</p><p>$$\phi(n) = N \times \frac{p^1-1}{p^1} \times \frac{p^2-1}{p^2} \times \cdots \times \frac{p^m-1}{p^m}$$</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>若整数$a$和整数$b$除以正整数$m$的余数相等，则称为$a$，$b$模$m$余数相同，则称为$a$，$b$模$m$同余，记为$a \equiv b\pmod m$。</p><p>同余满足反身性、对称性、传递性。</p><ul><li><p>$a \equiv a\pmod m$</p></li><li><p>若$a \equiv b\pmod m$，则$b \equiv a\pmod m$</p></li><li><p>若$a \equiv b\pmod m$，$b \equiv c\pmod m$，则$a \equiv c\pmod m$</p></li></ul><h3 id="翡翠定理"><a href="#翡翠定理" class="headerlink" title="翡翠定理"></a>翡翠定理</h3><p>又称贝祖公式，指的是当$ax+by=m$有整数解时，只有$m$是$a$和$b$的<strong>最大公约数</strong>$d$的倍数。<br>翡翠等式有解时必然有无穷多个整数解，每组解$x$、$y$都成为<strong>翡翠数</strong>，可以使用<strong>扩展欧几里得算法</strong>求得。</p><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>已知整数$a$、$b$，扩展欧几里得算法可以在求得$a$、$b$的最大公约数的同时，找到整数$x$、$y$（其中一个很可能是负数），使它们满足翡翠等式$ax+by=gcd(a,b)$。<br>如果$a$是负数，可以把问题转化成$|a|(-x)+by=gcd(|a|,b)$，然后令$x’=(-x)$。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>$f(1) = 1$</p><p>$f(2) = 1$</p><p>$f(3) = f(1) + f(2) = f(3-2) + f(3-1)$</p><p>$f(n) = f(n-2) + f(n-1)$</p><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$f(0) = 1$</p><p>$f(1) = 1$</p><p>$f(n) = f(0) \times f(n-1) + f(1) \times f(n-2) \cdots + f(n) \times f(0)$</p><p>应用：长度为n的栈一共有多少种出栈的方法。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>前序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/2.jpg" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/2.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg"></p><h2 id="初赛知识点"><a href="#初赛知识点" class="headerlink" title="初赛知识点"></a>初赛知识点</h2><h3 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h3><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/6.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/6.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg"></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>相同为0，不同为1。</p><p>$n^{\wedge}0$不变，$n^{\wedge}1$取反。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>源码的绝对值取反加1。</p><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算数运算符</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/3.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/3.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg"></p><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>$$<br>A^m_n=n \times (n-1) \times (n-2) \times \cdots \times (n-m+1) = \frac{n!}{(n-m)!}<br>$$</p><h4 id="全组合"><a href="#全组合" class="headerlink" title="全组合"></a>全组合</h4><p>$$<br>C^m_n= \frac{A^m_n}{A^m_m} = \frac{n \times (n-1) \times (n-2) \times \cdots \times (n-m+1)}{1 \times 2 \times 3 \times 4 \times \cdots \times m} = \frac{n!}{m!(n-m)!}<br>$$</p><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>$A[1 \ldots n]$如有$i \lt j$且$A[i] \gt A[j]$则称为逆序对。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>$$(a \times b) \bmod p = (a \bmod p \times b \bmod p) \bmod p$$</p><p>$$(a+b) \bmod p = (a \bmod p + b \bmod p) \bmod p$$</p><p>$$(a-b) \bmod p = (a \bmod p - b \bmod p) \bmod p$$</p><p>$$(a^b \bmod p) = ((a \bmod p) ^ b) \bmod p$$</p><p>$$((a+b) \bmod p + c) \bmod p = (a + (b+c) \bmod p) \bmod p$$</p><p>$$((a+b) \bmod p \times c) \bmod p = ((a \times c) \bmod p + (b \times c) \bmod p) \bmod p$$</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><code>mid = (l + r) / 2;</code>等价于<code>mid = l + (r - l) / 2</code>。</p><p>第一种写法可能会爆<code>int</code>。</p><p><strong>求最小值最大（最大值最小）一般使用二分答案来进行求解。</strong></p><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erfen</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 注意二分条件</span></span><br><span class="line">        mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">erfen</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123; <span class="comment">// dlt = 0.001(精度)</span></span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(l-r) &gt; dlt) &#123;</span><br><span class="line">        mid = (l+r) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Min-heap: 父节点的值小于或等于子节点的值。</p><p>Max-heap: 父节点的值大于或等于子节点的值。</p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/1.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/1.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg"></p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li><p><code>upper_bound</code><br>找到第一个大于<code>x</code>的数。</p></li><li><p><code>lower_bound</code><br>找到第一个大于等于<code>x</code>的数。</p></li><li><p><code>greater&lt;int&gt;()</code><br>降序排列。</p></li><li><p><code>less&lt;int&gt;()</code><br>升序排列。</p></li><li><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;</code><br>优先队列（大根堆）。</p></li><li><p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap;</code><br>优先队列（小根堆）。</p></li><li><p><code>next_permutation(a, a+n)</code><br>生成a的全排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(a, a + n);</span><br></pre></td></tr></table></figure></li></ul><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li><p><code>scanf(&quot; %c&quot;, &amp;n)</code><br>其中<code>%c</code>前面加一个空格可以过滤掉一切的<strong>空格</strong>，<strong>回车</strong>以及<strong>Tab</strong>，如果没有的话则不影响。</p></li><li><p>函数有返回值而不返回或者数组下标越界可能会产生各种奇怪的问题，比如C++11能AC但是C++14会RE等等。</p></li><li><p>用<code>memset</code>给<code>int</code>赋值为<code>0x7f</code>即为近似最大值，二进制位为<code>0111 0111 0111 0111</code>。</p></li><li><p>有向无环图的单源点最短路使用BFS算法最佳。</p></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="搜索究竟解决的是一个什么问题？"><a href="#搜索究竟解决的是一个什么问题？" class="headerlink" title="搜索究竟解决的是一个什么问题？"></a>搜索究竟解决的是一个什么问题？</h3><blockquote><p>在某一个空间里寻找目标。</p><p>空间指的是<strong>解空间</strong>。</p><p>目标指的是<strong>目标状态</strong>。</p></blockquote><ul><li>解空间：如果把一个问题的解抽象成一个数学上的向量，那么包含这个向量的空间，就是解空间。</li><li>目标状态：用于描述问题或者问题的解的一些量（我是谁？我在哪？）。</li></ul><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/4.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/4.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="解空间和目标状态"></p><p><img src="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/5.png" class="lazyload placeholder" data-srcset="https://rainbowbird.oss-cn-beijing.aliyuncs.com/posts/algorithmic-learning-notes/5.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="目标状态举例"></p><p>(有助于理解动态规划?)</p><h3 id="判断N是否是质数，为什么判断到根号n就可以了？"><a href="#判断N是否是质数，为什么判断到根号n就可以了？" class="headerlink" title="判断N是否是质数，为什么判断到根号n就可以了？"></a>判断N是否是质数，为什么判断到根号n就可以了？</h3><div class="note quote"><p>以下内容摘自<a href="https://www.zhihu.com/question/21808179/answer/21250639">知乎</a>。</p></div><p>首先，约数是成对出现的。比如24，你找到个约数3，那么一定有个约数8，因为24/3=8。</p><p>然后，这对约数必须一个在根号n之前，一个在根号n之后。因为都在根号n之前的话，乘积一定小于n（根号nX根号n=n），同样，都在根号n之后的话，乘积一定大于n。</p><p>所以，如果你在根号n之前都找不到约数的话，那么根号n之后就不会有了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 初赛 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】USACO 愤怒的牛</title>
      <link href="//posts/algorithm-soultion/usaco-the-angry-bull.html"/>
      <url>//posts/algorithm-soultion/usaco-the-angry-bull.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://loj.ac/problem/10011">「一本通 1.2 例 1」愤怒的牛</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>所谓二分答案就是把所有的答案用二分的方法遍历一遍（前提是有序的单调序列），然后再用<code>check()</code>函数来判断答案的可行性。</p><div class="note info">            <p><span class='p yellow'>求最小值最大</span>或<span class='p yellow'>求最大值最小</span>是典型的二分答案。</p>          </div><p>要注意的是二分的边界。</p><blockquote><p>推荐阅读：<a href="https://blog.csdn.net/qq1515312832/article/details/105846202">二分查找怎么写，边界如何确定，我应该是要左边还是要右边，我为何如此的蠢？？？</a></p></blockquote><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P10011 愤怒的牛</span></span><br><span class="line"><span class="comment"> * 来源: 信息学奥赛一本通 提高篇</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-29</span></span><br><span class="line"><span class="comment"> * 算法: 二分答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = a[<span class="number">0</span>]; <span class="comment">// 先塞第一个牛棚</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.begin() + <span class="number">1</span>; it != a.end(); it++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的牛棚和上一个牛棚的距离大于或等于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (*it - last &gt;= x) &#123;</span><br><span class="line">            last = *it;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以把牛全部放进牛棚</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        a.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(), a.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [l, r]为闭区间</span></span><br><span class="line">    <span class="keyword">int</span> l = a[<span class="number">0</span>], r = a[n<span class="number">-1</span>]; <span class="comment">// l, r, mid都为距离</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// mid为最短距离的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2000 进制转换</title>
      <link href="//posts/algorithm-soultion/noip2000-sys-convert.html"/>
      <url>//posts/algorithm-soultion/noip2000-sys-convert.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1017">P1017 进制转换</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题考察的是负进制转换。</p><p>我们都知道，十进制转化为二进制应该不断用原数除以2取余，得到的余数由高位到低位排列则能得到十进制数字在二进制下的数字。</p><a id="more"></a><p>十进制转二进制的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary[<span class="number">255</span>], cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    binary[++cur] = n % m;</span><br><span class="line">    n /= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中n为十进制下的数字，m为需要转换的进制。</p></blockquote><p>那么当目标进制为负数的时候要注意什么呢？</p><p><strong>余数不能为负数</strong>。</p><p>例如，$(19)_{10}$要转换成$-9$进制。</p><p>$19/-9=-2…1$</p><p>$-2/-9=1…7$（注意这里不是<emp>$0...-2$</emp>！因为负数不能做余数。）</p><p>$1/-9=0…1$（当商为0时计算完成）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P1017 进制转换</span></span><br><span class="line"><span class="comment"> * 来源: NOIP2000</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-28</span></span><br><span class="line"><span class="comment"> * 算法: 负进制转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> nums[<span class="number">20</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">10005</span>], cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; <span class="comment">// 注意这里是不等于，因为商可能为负数</span></span><br><span class="line">        <span class="keyword">int</span> mod = n % r; <span class="comment">// 获取余数</span></span><br><span class="line">        n /= r;          <span class="comment">// 获取商</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果余数小于0，那么商进一位，余数则等于进制数的绝对值减去余数的绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (mod &lt; <span class="number">0</span>) n++, mod = <span class="built_in">abs</span>(r) - <span class="built_in">abs</span>(mod);</span><br><span class="line">        ans[cur++] = nums[mod];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由高位到低位倒序输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ans[i]); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(base%d)\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】双向BFS</title>
      <link href="//posts/algorithm-template/tamplate-twophase-bfs.html"/>
      <url>//posts/algorithm-template/tamplate-twophase-bfs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们都知道BFS搜索的时间复杂度为$O(N^2)$。</p><p>而双向BFS搜索因为是从两边开始搜索，时间复杂度会优化很多，为朴素BFS的时间复杂度开根号。</p><p>下面请看模板代码。</p><a id="more"></a><p>输入样例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">..###</span><br><span class="line">#....</span><br><span class="line">#.#.#</span><br><span class="line">#.#.#</span><br><span class="line">#.#..</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> nextn[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">55</span>][<span class="number">55</span>], vst[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; que1; <span class="comment">// 向前搜 </span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; que2; <span class="comment">// 向后搜 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vst标记状态 dis表示路程 </span></span><br><span class="line">    que1.push(Node&#123;<span class="number">1</span>, <span class="number">1</span>&#125;), dis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>, vst[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    que2.push(Node&#123;n, m&#125;), dis[n][m] = <span class="number">1</span>, vst[n][m] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que1.empty() &amp;&amp; !que2.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag; </span><br><span class="line">        Node head;</span><br><span class="line">        <span class="keyword">if</span> (que1.size() &gt; que2.size()) &#123; <span class="comment">// 哪个队列元素少就从哪个队列开始搜 </span></span><br><span class="line">            head = que2.front(); <span class="comment">// 向前搜</span></span><br><span class="line">            que2.pop();</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = que1.front(); <span class="comment">// 向后搜</span></span><br><span class="line">            que1.pop();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tx = head.x + nextn[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ty = head.y + nextn[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tx &gt; n || ty &gt; m || tx &lt;= <span class="number">0</span> || ty &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dis[tx][ty]) &#123; <span class="comment">// 这一步没有队列走过</span></span><br><span class="line">                    dis[tx][ty] = dis[head.x][head.y] + <span class="number">1</span>; <span class="comment">// 路程加一 </span></span><br><span class="line">                    vst[tx][ty] = vst[head.x][head.y]; <span class="comment">// 继承状态 </span></span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">1</span>) que1.push(Node&#123;tx, ty&#125;); </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) que2.push(Node&#123;tx, ty&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vst[head.x][head.y] + vst[tx][ty] == <span class="number">3</span>) &#123; <span class="comment">// 如果相遇 </span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; dis[head.x][head.y] + dis[tx][ty] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 步数相加 </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP2003 乒乓球</title>
      <link href="//posts/algorithm-soultion/noip2003-table-tennis.html"/>
      <url>//posts/algorithm-soultion/noip2003-table-tennis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这道题我交了好几次，果然还是太菜了（</p><p>说一下注意的点吧：</p><ul><li>要特判一下只有<code>E</code>的情况，应该输出<code>0:0</code></li><li>这里的11分制是指其中一个人有11分而不是总共11分</li><li>要注意刚好比完一场还需要进行下一场，如果下一场没有数据应该输出<code>0:0</code></li></ul><a id="more"></a><p>具体请看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P1217 乒乓球</span></span><br><span class="line"><span class="comment"> * 作者: RainbowBird</span></span><br><span class="line"><span class="comment"> * 日期: 2020-08-18</span></span><br><span class="line"><span class="comment"> * 算法: 模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, game[<span class="number">25</span> * <span class="number">2500</span> + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="built_in">memset</span>(game, <span class="number">0</span>, <span class="keyword">sizeof</span>(game));</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;W&#x27;</span>) game[++n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;L&#x27;</span>) game[++n] = <span class="number">2</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11分制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行一轮比赛</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &gt;= <span class="number">11</span> || b &gt;= <span class="number">11</span>) &amp;&amp; <span class="built_in">abs</span>(a-b) &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (game[k] == <span class="number">1</span>) a++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (game[k] == <span class="number">2</span>) b++;</span><br><span class="line"></span><br><span class="line">                k++, i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束这一轮比赛</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 21分制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行一轮比赛</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt;= n + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &gt;= <span class="number">21</span> || b &gt;= <span class="number">21</span>) &amp;&amp; <span class="built_in">abs</span>(a-b) &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (game[k] == <span class="number">1</span>) a++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (game[k] == <span class="number">2</span>) b++;</span><br><span class="line"></span><br><span class="line">                k++, i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束这一轮比赛</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】高精度模板</title>
      <link href="//posts/algorithm-template/high-precision-template.html"/>
      <url>//posts/algorithm-template/high-precision-template.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>高精度加、减、乘（高精乘高精）、除（高精除以高精）模板。</p><a id="more"></a><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena + lenb; i++) &#123;</span><br><span class="line">        nc[i] += na[i] + nb[i];</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>]++;</span><br><span class="line">            nc[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lenc &gt; <span class="number">0</span> &amp;&amp; nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sub</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena + lenb; i++) &#123;</span><br><span class="line">        nc[i] += na[i] - nb[i];</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>]--;</span><br><span class="line">            nc[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lenc &gt; <span class="number">0</span> &amp;&amp; nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">mul</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">105</span>], nb[<span class="number">105</span>], nc[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++)</span><br><span class="line">        na[i] = a[lena - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++)</span><br><span class="line">        nb[i] = b[lenb - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">            nc[i+j<span class="number">-1</span>] += na[i] * nb[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lena + lenb; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nc[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            nc[i+<span class="number">1</span>] += nc[i] / <span class="number">10</span>;</span><br><span class="line">            nc[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenc = lena + lenb + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nc[--lenc] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt;= <span class="number">1</span>; i--) c[lenc-i] = nc[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[last+len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果被除数的位数比除数大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i+last<span class="number">-1</span>] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i+last<span class="number">-1</span>] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相等返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="keyword">int</span> lena = a.length(), lenb = b.length(), lenc = lena - lenb + <span class="number">2</span>, lend = max(lena, lenb) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空变量</span></span><br><span class="line">    <span class="built_in">memset</span>(na, <span class="number">0</span>, <span class="keyword">sizeof</span>(na));</span><br><span class="line">    <span class="built_in">memset</span>(nb, <span class="number">0</span>, <span class="keyword">sizeof</span>(nb));</span><br><span class="line">    <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span>(nc)); <span class="comment">// 商</span></span><br><span class="line">    <span class="built_in">memset</span>(nd, <span class="number">0</span>, <span class="keyword">sizeof</span>(nd)); <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把数字倒过来存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) na[i] = a[lena-i] - <span class="string">&#x27;0&#x27;</span>, nd[i] = na[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) nb[i] = b[lenb-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= lena; i++) nd[i] = na[i]; // 存余数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高精度除法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lena - lenb + <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 被除数和除数对齐</span></span><br><span class="line">        <span class="comment">/* 456 / 12</span></span><br><span class="line"><span class="comment">         *      38</span></span><br><span class="line"><span class="comment">         * 12 |----</span></span><br><span class="line"><span class="comment">         *     456</span></span><br><span class="line"><span class="comment">         *     36</span></span><br><span class="line"><span class="comment">         *     ----</span></span><br><span class="line"><span class="comment">         *      96</span></span><br><span class="line"><span class="comment">         *      96</span></span><br><span class="line"><span class="comment">         *     ----</span></span><br><span class="line"><span class="comment">         *       0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以相减</span></span><br><span class="line">        <span class="keyword">while</span> (cmp(nd, nb, i, lenb)) &#123;</span><br><span class="line">            <span class="comment">// 高精度减法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">                nd[i+j<span class="number">-1</span>] -= nb[j];</span><br><span class="line">                <span class="keyword">if</span> (nd[i+j<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nd[i+j]--;</span><br><span class="line">                    nd[i+j<span class="number">-1</span>] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nc[i]++; <span class="comment">// 商进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出商</span></span><br><span class="line">    <span class="keyword">while</span> (nc[--lenc] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lenc &lt;= <span class="number">0</span>) lenc++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenc; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nc[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出余数</span></span><br><span class="line">    <span class="keyword">while</span> (nd[--lend] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lend &lt;= <span class="number">0</span>) lend++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lend; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nd[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛-模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
